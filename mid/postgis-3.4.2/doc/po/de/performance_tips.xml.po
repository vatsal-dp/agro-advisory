# SOME DESCRIPTIVE TITLE.
#
# Translators:
# Andreas Schild <andreas.schild@bfw.gv.at>, 2017,2019
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-07-15 01:28+0000\n"
"PO-Revision-Date: 2019-03-11 09:10+0000\n"
"Last-Translator: Andreas Schild <andreas.schild@bfw.gv.at>\n"
"Language-Team: German (http://www.transifex.com/postgis/postgis/language/"
"de/)\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: performance_tips.xml:3
#, fuzzy, no-c-format
msgid "Performance Tips"
msgstr "Performance Tipps"

#. Tag: title
#: performance_tips.xml:6
#, no-c-format
msgid "Small tables of large geometries"
msgstr "Kleine Tabellen mit großen Geometrien"

#. Tag: title
#: performance_tips.xml:9
#, no-c-format
msgid "Problem description"
msgstr "Problembeschreibung"

#. Tag: para
#: performance_tips.xml:11
#, no-c-format
msgid ""
"Current PostgreSQL versions (including 9.6) suffer from a query optimizer "
"weakness regarding TOAST tables. TOAST tables are a kind of \"extension "
"room\" used to store large (in the sense of data size) values that do not "
"fit into normal data pages (like long texts, images or complex geometries "
"with lots of vertices), see <ulink url=\"http://www.postgresql.org/docs/"
"current/static/storage-toast.html\">the PostgreSQL Documentation for TOAST</"
"ulink> for more information)."
msgstr ""
"Aktuelle PostgreSQL Versionen (inklusive 9.6) haben eine Schwäche des "
"Optimizers in Bezug auf TOAST Tabellen. TOAST Tabellen bieten eine Art "
"\"Erweiterungsraum\", der benutzt wird um große Werte (im Sinne der "
"Datengröße), welche nicht in die üblichen Datenspeicherseiten passen (wie "
"lange Texte, Bilder oder eine komplexe Geometrie mit vielen Stützpunkten) "
"auszulagern, siehe  <ulink url=\"http://www.postgresql.org/docs/current/"
"static/storage-toast.html\">the PostgreSQL Documentation for TOAST</ulink> "
"für mehr Information)."

#. Tag: para
#: performance_tips.xml:19
#, fuzzy, no-c-format
msgid ""
"The problem appears if you happen to have a table with rather large "
"geometries, but not too many rows of them (like a table containing the "
"boundaries of all European countries in high resolution). Then the table "
"itself is small, but it uses lots of TOAST space. In our example case, the "
"table itself had about 80 rows and used only 3 data pages, but the TOAST "
"table used 8225 pages."
msgstr ""
"Das Problem tritt bei Tabellen mit relativ großen Geometrien, aber wenigen "
"Zeilen auf (z.B. eine Tabelle welche die europäischen Ländergrenzen in hoher "
"Auflösung beinhaltet). Dann ist die Tabelle selbst klein, aber sie benützt "
"eine Menge an TOAST Speicherplatz. In unserem Beispiel hat die Tabelle um "
"die 80 Zeilen und nutzt dafür nur 3 Speicherseiten, während die TOAST "
"Tabelle 8225 Speicherseiten benützt."

#. Tag: para
#: performance_tips.xml:26
#, no-c-format
msgid ""
"Now issue a query where you use the geometry operator &amp;&amp; to search "
"for a bounding box that matches only very few of those rows. Now the query "
"optimizer sees that the table has only 3 pages and 80 rows. It estimates "
"that a sequential scan on such a small table is much faster than using an "
"index. And so it decides to ignore the GIST index. Usually, this estimation "
"is correct. But in our case, the &amp;&amp; operator has to fetch every "
"geometry from disk to compare the bounding boxes, thus reading all TOAST "
"pages, too."
msgstr ""
"Stellen Sie sich nun eine Abfrage vor, die den geometrischen Operator &amp;"
"&amp; verwendet, um ein Umgebungsrechteck mit nur wenigen Zeilen zu "
"ermitteln. Der Abfrageoptimierer stellt fest, dass die Tabelle nur 3 "
"Speicherseiten und 80 Zeilen aufweist. Er nimmt an, das ein sequentieller "
"Scan bei einer derart kleinen Tabelle wesentlich schneller abläuft als die "
"Verwendung eines Indizes. Und so entscheidet er den GIST Index zu "
"ignorieren. Normalerweise stimmt diese Annahme. Aber in unserem Fall, muss "
"der &amp;&amp; Operator die gesamte Geometrie von der Festplatte lesen um "
"den BoundingBox-Vergleich durchführen zu können, wodurch auch alle TOAST-"
"Speicherseiten gelesen werden. "

#. Tag: para
#: performance_tips.xml:35
#, fuzzy, no-c-format
msgid ""
"To see whether your suffer from this issue, use the \"EXPLAIN ANALYZE\" "
"postgresql command. For more information and the technical details, you can "
"read the thread on the PostgreSQL performance mailing list: <ulink "
"url=\"http://archives.postgresql.org/pgsql-performance/2005-02/msg00030."
"php\">http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php</"
"ulink>"
msgstr ""
"Um zu sehen, ob dieses Problem auftritt, können Sie den \"EXPLAIN ANALYZE\" "
"Befehl von PostgreSQL anwenden. Mehr Information und die technischen "
"Feinheiten entnehmen Sie bitte dem Thread auf der Postgres Performance "
"Mailing List: http://archives.postgresql.org/pgsql-performance/2005-02/"
"msg00030.php"

#. Tag: para
#: performance_tips.xml:41
#, no-c-format
msgid ""
"and newer thread on PostGIS <ulink url=\"https://lists.osgeo.org/pipermail/"
"postgis-devel/2017-June/026209.html\">https://lists.osgeo.org/pipermail/"
"postgis-devel/2017-June/026209.html</ulink>"
msgstr ""
"und einem neueren Thread über PostGIS <ulink url=\"https://lists.osgeo.org/"
"pipermail/postgis-devel/2017-June/026209.html\">https://lists.osgeo.org/"
"pipermail/postgis-devel/2017-June/026209.html</ulink>"

#. Tag: title
#: performance_tips.xml:45
#, no-c-format
msgid "Workarounds"
msgstr "Umgehungslösung"

#. Tag: para
#: performance_tips.xml:47
#, no-c-format
msgid ""
"The PostgreSQL people are trying to solve this issue by making the query "
"estimation TOAST-aware. For now, here are two workarounds:"
msgstr ""
"Die PostgreSQL Entwickler versuchen das Problem zu lösen, indem sie die "
"Abschätzung der Abfragen TOAST-gewahr machen. Zur Überbrückung zwei "
"Workarounds:"

#. Tag: para
#: performance_tips.xml:50
#, no-c-format
msgid ""
"The first workaround is to force the query planner to use the index. Send "
"\"SET enable_seqscan TO off;\" to the server before issuing the query. This "
"basically forces the query planner to avoid sequential scans whenever "
"possible. So it uses the GIST index as usual. But this flag has to be set on "
"every connection, and it causes the query planner to make misestimations in "
"other cases, so you should \"SET enable_seqscan TO on;\" after the query."
msgstr ""
"Der erste Workaround besteht darin den Query Planer zu zwingen, den Index zu "
"nutzen. Setzen Sie \"SET enable_seqscan TO off;\" am Server bevor Sie die "
"Abfrage ausführen. Dies zwingt den Query Planer grundsätzlich dazu "
"sequentielle Scans, wann immer möglich, zu vermeiden. Womit der GIST Index "
"wie üblich verwendet wird. Aber dieser Parameter muss bei jeder Verbindung "
"neu gesetzt werden, und er verursacht das der Query Planer "
"Fehleinschätzungen in anderen Fällen macht. Daher sollte \"SET "
"enable_seqscan TO on;\" nach der Abfrage ausgeführt werden."

#. Tag: para
#: performance_tips.xml:58
#, no-c-format
msgid ""
"The second workaround is to make the sequential scan as fast as the query "
"planner thinks. This can be achieved by creating an additional column that "
"\"caches\" the bbox, and matching against this. In our example, the commands "
"are like:"
msgstr ""
"Der zweite Workaround besteht darin, den sequentiellen Scan so schnell zu "
"machen wie der Query Planer annimmt. Dies kann durch eine zusätzliche "
"Spalte, welche die BBOX \"zwischenspeichert\" und über die abgefragt wird, "
"erreicht werden. In Unserem Beispiel sehen die Befehle dazu folgendermaßen "
"aus:"

#. Tag: para
#: performance_tips.xml:65
#, no-c-format
msgid ""
"Now change your query to use the &amp;&amp; operator against bbox instead of "
"geom_column, like:"
msgstr ""
"Nun ändern Sie bitte Ihre Abfrage so, das der &amp;&amp; Operator gegen die "
"bbox anstelle der geom_column benutzt wird:"

#. Tag: para
#: performance_tips.xml:70
#, no-c-format
msgid ""
"Of course, if you change or add rows to mytable, you have to keep the bbox "
"\"in sync\". The most transparent way to do this would be triggers, but you "
"also can modify your application to keep the bbox column current or run the "
"UPDATE query above after every modification."
msgstr ""
"Selbstverständlich muss man die BBOX synchron halten. Die transparenteste "
"Möglichkeit dies zu erreichen wäre über Trigger. Sie können Ihre Anwendung "
"derart abändern, das die BBOX Spalte aktuell bleibt oder ein UPDATE nach "
"jeder Änderung durchführen."

#. Tag: title
#: performance_tips.xml:79
#, no-c-format
msgid "CLUSTERing on geometry indices"
msgstr "CLUSTER auf die geometrischen Indizes"

#. Tag: para
#: performance_tips.xml:81
#, no-c-format
msgid ""
"For tables that are mostly read-only, and where a single index is used for "
"the majority of queries, PostgreSQL offers the CLUSTER command. This command "
"physically reorders all the data rows in the same order as the index "
"criteria, yielding two performance advantages: First, for index range scans, "
"the number of seeks on the data table is drastically reduced. Second, if "
"your working set concentrates to some small intervals on the indices, you "
"have a more efficient caching because the data rows are spread along fewer "
"data pages. (Feel invited to read the CLUSTER command documentation from the "
"PostgreSQL manual at this point.)"
msgstr ""
"Für Tabelle die hauptsächlich read-only sind und bei denen ein einzelner "
"Index für die Mehrheit der Abfragen verwendet wird, bietet PostgreSQL den "
"CLUSTER Befehl. Dieser Befehl ordnet alle Datenzeilen in derselben "
"Reihenfolge an wie die Kriterien bei der Indexerstellung, was zu zwei "
"Performance Vorteilen führt: Erstens wird für die Index Range Scans die "
"Anzahl der Suchabfragen über die Datentabelle stark reduziert. Zweitens, "
"wenn sich der Arbeitsbereich auf einige kleine Intervale des Index "
"beschränkt ist das Caching effektiver, da die Datenzeilen über weniger data "
"pages verteilt sind. (Sie dürfen sich nun eingeladen fühlen, die "
"Dokumentation über den CLUSTER Befehl in der PostgreSQL Hilfe nachzulesen.)"

#. Tag: para
#: performance_tips.xml:91
#, no-c-format
msgid ""
"However, currently PostgreSQL does not allow clustering on PostGIS GIST "
"indices because GIST indices simply ignores NULL values, you get an error "
"message like:"
msgstr ""
"Die aktuelle PostgreSQL Version erlaubt allerdings kein clustern an Hand von "
"PostGIS GIST Indizes, da GIST Indizes NULL Werte einfach ignorieren. Sie "
"erhalten eine Fehlermeldung wie:"

#. Tag: para
#: performance_tips.xml:97
#, no-c-format
msgid ""
"As the HINT message tells you, one can work around this deficiency by adding "
"a \"not null\" constraint to the table:"
msgstr ""
"Wie die HINT Meldung mitteilt, kann man diesen Mangel umgehen indem man eine "
"\"NOT NULL\" Bedingung auf die Tabelle setzt:"

#. Tag: para
#: performance_tips.xml:102
#, no-c-format
msgid ""
"Of course, this will not work if you in fact need NULL values in your "
"geometry column. Additionally, you must use the above method to add the "
"constraint, using a CHECK constraint like \"ALTER TABLE blubb ADD CHECK "
"(geometry is not null);\" will not work."
msgstr ""
"Dies funktioniert natürlich nicht, wenn Sie tatsächlich NULL Werte in Ihrer "
"Geometriespalte benötigen. Außerdem müssen Sie die obere Methode zum "
"Hinzufügen der Bedingung verwenden. Die Verwendung einer CHECK Bedingung "
"wie  \"ALTER TABLE blubb ADD CHECK (geometry is not null);\" wird nicht "
"klappen."

#. Tag: title
#: performance_tips.xml:109
#, no-c-format
msgid "Avoiding dimension conversion"
msgstr "Vermeidung von Dimensionsumrechnungen"

#. Tag: para
#: performance_tips.xml:111
#, no-c-format
msgid ""
"Sometimes, you happen to have 3D or 4D data in your table, but always access "
"it using OpenGIS compliant ST_AsText() or ST_AsBinary() functions that only "
"output 2D geometries. They do this by internally calling the ST_Force2D() "
"function, which introduces a significant overhead for large geometries. To "
"avoid this overhead, it may be feasible to pre-drop those additional "
"dimensions once and forever:"
msgstr ""
"Manchmal kann es vorkommen, das Sie 3D- oder 4D-Daten in Ihrer Tabelle "
"haben, aber immer mit den OpenGIS compliant ST_AsText() oder ST_AsBinary() "
"Funktionen, die lediglich 2D Geometrien ausgeben, zugreifen. Dies geschieht "
"indem intern die ST_Force2D() Funktion aufgerufen wird, welche einen "
"wesentlichen Overhead für große Geometrien aufweist. Um diesen Overhead zu "
"vermeiden kann es praktikabel sein diese zusätzlichen Dimensionen ein für "
"alle mal im Voraus zu löschen:"

#. Tag: para
#: performance_tips.xml:120
#, no-c-format
msgid ""
"Note that if you added your geometry column using AddGeometryColumn() "
"there'll be a constraint on geometry dimension. To bypass it you will need "
"to drop the constraint. Remember to update the entry in the geometry_columns "
"table and recreate the constraint afterwards."
msgstr ""
"Beachten Sie bitte, falls Sie die Geometriespalte über AddGeometryColumn() "
"hinzugefügt haben, das dadurch eine Bedingung auf die Dimension der "
"Geometrie gesetzt ist. Um dies zu Überbrücken löschen Sie die Bedingung. "
"Vergessen Sie bitte nicht den Eintrag in die geometry_columns Tabelle zu "
"erneuern und die Bedingung anschließend erneut zu erzeugen."

#. Tag: para
#: performance_tips.xml:126
#, fuzzy, no-c-format
msgid ""
"In case of large tables, it may be wise to divide this UPDATE into smaller "
"portions by constraining the UPDATE to a part of the table via a WHERE "
"clause and your primary key or another feasible criteria, and running a "
"simple \"VACUUM;\" between your UPDATEs. This drastically reduces the need "
"for temporary disk space. Additionally, if you have mixed dimension "
"geometries, restricting the UPDATE by \"WHERE dimension(geom)&gt;2\" skips "
"re-writing of geometries that already are in 2D."
msgstr ""
"Bei großen Tabellen kann es vernünftig sein, diese UPDATE in mehrere "
"kleinere Portionen aufzuteilen, indem man das UPDATE mittels WHERE Klausel "
"und eines Primärschlüssels, oder eines anderen passenden Kriteriums, "
"beschränkt und ein einfaches \"VACUUM;\" zwischen den UPDATEs aufruft. Dies "
"verringert den Bedarf an temporären Festplattenspeicher drastisch. Außerdem, "
"falls die Datenbank gemischte Dimensionen der Geometrie aufweist, kann eine "
"Einschränkung des UPDATES mittels \"WHERE dimension(the_geom)&gt;2\" das "
"wiederholte Schreiben von Geometrien, welche bereits in 2D sind, vermeiden."
