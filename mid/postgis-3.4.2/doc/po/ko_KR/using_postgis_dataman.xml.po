# SOME DESCRIPTIVE TITLE.
#
# Translators:
# BJ Jang <qgis.tr.kr@gmail.com>, 2013
# HANJIN LEE <jinifor@gmail.com>, 2015
# Kwon.Yongchan <ruvyn@naver.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-07-15 12:17+0000\n"
"PO-Revision-Date: 2016-07-22 07:09+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>\n"
"Language-Team: Korean (Korea) (http://www.transifex.com/postgis/postgis/"
"language/ko_KR/)\n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Data Management"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:6
#, fuzzy, no-c-format
msgid "Spatial Data Model"
msgstr "GIS (벡터) 데이터 로드"

#. Tag: title
#: using_postgis_dataman.xml:9
#, no-c-format
msgid "OGC Geometry"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:11
#, no-c-format
msgid ""
"The Open Geospatial Consortium (OGC) developed the <ulink url=\"https://www."
"ogc.org/standards/sfa\"><emphasis>Simple Features Access</emphasis></ulink> "
"standard (SFA) to provide a model for geospatial data. It defines the "
"fundamental spatial type of <emphasis role=\"bold\">Geometry</emphasis>, "
"along with operations which manipulate and transform geometry values to "
"perform spatial analysis tasks. PostGIS implements the OGC Geometry model as "
"the PostgreSQL data types <link linkend=\"PostGIS_Geometry\">geometry</link> "
"and <link linkend=\"PostGIS_Geography\">geography</link>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:21
#, no-c-format
msgid ""
"Geometry is an <emphasis>abstract</emphasis> type. Geometry values belong to "
"one of its <emphasis>concrete</emphasis> subtypes which represent various "
"kinds and dimensions of geometric shapes. These include the <emphasis "
"role=\"bold\">atomic</emphasis> types <link linkend=\"Point\">Point</link>, "
"<link linkend=\"LineString\">LineString</link>, <link "
"linkend=\"LinearRing\">LinearRing</link> and <link "
"linkend=\"Polygon\">Polygon</link>, and the <emphasis "
"role=\"bold\">collection</emphasis> types <link "
"linkend=\"MultiPoint\">MultiPoint</link>, <link "
"linkend=\"MultiLineString\">MultiLineString</link>, <link "
"linkend=\"MultiPolygon\">MultiPolygon</link> and <link "
"linkend=\"GeometryCollection\">GeometryCollection</link>. The <ulink "
"url=\"https://portal.ogc.org/files/?artifact_id=25355\"><emphasis>Simple "
"Features Access - Part 1: Common architecture v1.2.1</emphasis></ulink> adds "
"subtypes for the structures <link "
"linkend=\"PolyhedralSurface\">PolyhedralSurface</link>, <link "
"linkend=\"Triangle\">Triangle</link> and <link linkend=\"TIN\">TIN</link>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:42
#, no-c-format
msgid ""
"Geometry models shapes in the 2-dimensional Cartesian plane. The "
"PolyhedralSurface, Triangle, and TIN types can also represent shapes in 3-"
"dimensional space. The size and location of shapes are specified by their "
"<emphasis role=\"bold\">coordinates</emphasis>. Each coordinate has a X and "
"Y <emphasis role=\"bold\">ordinate</emphasis> value determining its location "
"in the plane. Shapes are constructed from points or line segments, with "
"points specified by a single coordinate, and line segments by two "
"coordinates."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:50
#, no-c-format
msgid ""
"Coordinates may contain optional Z and M ordinate values. The Z ordinate is "
"often used to represent elevation. The M ordinate contains a measure value, "
"which may represent time or distance. If Z or M values are present in a "
"geometry value, they must be defined for each point in the geometry. If a "
"geometry has Z or M ordinates the <emphasis role=\"bold\">coordinate "
"dimension</emphasis> is 3D; if it has both Z and M the coordinate dimension "
"is 4D."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:58
#, no-c-format
msgid ""
"Geometry values are associated with a <emphasis role=\"bold\">spatial "
"reference system</emphasis> indicating the coordinate system in which it is "
"embedded. The spatial reference system is identified by the geometry SRID "
"number. The units of the X and Y axes are determined by the spatial "
"reference system. In <emphasis role=\"bold\">planar</emphasis> reference "
"systems the X and Y coordinates typically represent easting and northing, "
"while in <emphasis role=\"bold\">geodetic</emphasis> systems they represent "
"longitude and latitude. SRID 0 represents an infinite Cartesian plane with "
"no units assigned to its axes. See <xref linkend=\"spatial_ref_sys\"/>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:71
#, no-c-format
msgid ""
"The geometry <emphasis role=\"bold\">dimension</emphasis> is a property of "
"geometry types. Point types have dimension 0, linear types have dimension 1, "
"and polygonal types have dimension 2. Collections have the dimension of the "
"maximum element dimension."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"A geometry value may be <emphasis role=\"bold\">empty</emphasis>. Empty "
"values contain no vertices (for atomic geometry types) or no elements (for "
"collections)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:82
#, no-c-format
msgid ""
"An important property of geometry values is their spatial <emphasis "
"role=\"bold\">extent</emphasis> or <emphasis role=\"bold\">bounding box</"
"emphasis>, which the OGC model calls <emphasis role=\"bold\">envelope</"
"emphasis>. This is the 2 or 3-dimensional box which encloses the coordinates "
"of a geometry. It is an efficient way to represent a geometry's extent in "
"coordinate space and to check whether two geometries interact."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:90
#, no-c-format
msgid ""
"The geometry model allows evaluating topological spatial relationships as "
"described in <xref linkend=\"DE-9IM\"/>. To support this the concepts of "
"<emphasis role=\"bold\">interior</emphasis>, <emphasis "
"role=\"bold\">boundary</emphasis> and <emphasis role=\"bold\">exterior</"
"emphasis> are defined for each geometry type. Geometries are topologically "
"closed, so they always contain their boundary. The boundary is a geometry of "
"dimension one less than that of the geometry itself."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid ""
"The OGC geometry model defines validity rules for each geometry type. These "
"rules ensure that geometry values represents realistic situations (e.g. it "
"is possible to specify a polygon with a hole lying outside the shell, but "
"this makes no sense geometrically and is thus invalid). PostGIS also allows "
"storing and manipulating invalid geometry values. This allows detecting and "
"fixing them if needed. See <xref linkend=\"OGC_Validity\"/>"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:112
#, no-c-format
msgid "Point"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:113
#, no-c-format
msgid ""
"A Point is a 0-dimensional geometry that represents a single location in "
"coordinate space."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:118
#, no-c-format
msgid "LineString"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:119
#, no-c-format
msgid ""
"A LineString is a 1-dimensional line formed by a contiguous sequence of line "
"segments. Each line segment is defined by two points, with the end point of "
"one segment forming the start point of the next segment. An OGC-valid "
"LineString has either zero or two or more points, but PostGIS also allows "
"single-point LineStrings. LineStrings may cross themselves (self-intersect). "
"A LineString is <emphasis role=\"bold\">closed</emphasis> if the start and "
"end points are the same. A LineString is <emphasis role=\"bold\">simple</"
"emphasis> if it does not self-intersect."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:132
#, no-c-format
msgid "LinearRing"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:133
#, no-c-format
msgid ""
"A LinearRing is a LineString which is both closed and simple. The first and "
"last points must be equal, and the line must not self-intersect."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:139
#, no-c-format
msgid "Polygon"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:140
#, no-c-format
msgid ""
"A Polygon is a 2-dimensional planar region, delimited by an exterior "
"boundary (the shell) and zero or more interior boundaries (holes). Each "
"boundary is a <link linkend=\"LinearRing\">LinearRing</link>."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:149
#, no-c-format
msgid "MultiPoint"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:150
#, no-c-format
msgid "A MultiPoint is a collection of Points."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:155
#, no-c-format
msgid "MultiLineString"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:156
#, no-c-format
msgid ""
"A MultiLineString is a collection of LineStrings. A MultiLineString is "
"closed if each of its elements is closed."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:163
#, no-c-format
msgid "MultiPolygon"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:164
#, no-c-format
msgid ""
"A MultiPolygon is a collection of non-overlapping, non-adjacent Polygons. "
"Polygons in the collection may touch only at a finite number of points."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:171
#, no-c-format
msgid "GeometryCollection"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:172
#, no-c-format
msgid ""
"A GeometryCollection is a heterogeneous (mixed) collection of geometries."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:177
#, no-c-format
msgid "PolyhedralSurface"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:178
#, no-c-format
msgid ""
"A PolyhedralSurface is a contiguous collection of patches or facets which "
"share some edges. Each patch is a planar Polygon. If the Polygon coordinates "
"have Z ordinates then the surface is 3-dimensional."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:185
#, no-c-format
msgid "Triangle"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:186
#, no-c-format
msgid ""
"A Triangle is a polygon defined by three distinct non-collinear vertices. "
"Because a Triangle is a polygon it is specified by four coordinates, with "
"the first and fourth being equal."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:194
#, no-c-format
msgid "<title>TIN</title>"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:195
#, no-c-format
msgid ""
"A TIN is a collection of non-overlapping <link "
"linkend=\"Triangle\">Triangle</link>s representing a <ulink url=\"https://en."
"wikipedia.org/wiki/Triangulated_irregular_network\">Triangulated Irregular "
"Network</ulink>."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:206
#, fuzzy, no-c-format
msgid "SQL/MM Part 3 - Curves"
msgstr "SQL-MM Part 3"

#. Tag: para
#: using_postgis_dataman.xml:208
#, no-c-format
msgid ""
"The <ulink url=\"https://www.iso.org/obp/ui/#iso:std:iso-iec:13249:-3:ed-5:"
"v1:en\"><emphasis>ISO/IEC 13249-3 SQL Multimedia - Spatial</emphasis></"
"ulink> standard (SQL/MM) extends the OGC SFA to define Geometry subtypes "
"containing curves with circular arcs. The SQL/MM types support 3DM, 3DZ and "
"4D coordinates."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:215
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"SQL-MM 실행 과정에서 지정된 허용 오차를 기준으로 부동소수점을 비교합니다. 현"
"재 허용 오차는 1E-8입니다."

#. Tag: title
#: using_postgis_dataman.xml:220
#, no-c-format
msgid "CircularString"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:222
#, fuzzy, no-c-format
msgid ""
"CircularString is the basic curve type, similar to a LineString in the "
"linear world. A single arc segment is specified by three points: the start "
"and end points (first and third) and some other point on the arc. To specify "
"a closed circle the start and end points are the same and the middle point "
"is the opposite point on the circle diameter (which is the center of the "
"arc). In a sequence of arcs the end point of the previous arc is the start "
"point of the next arc, just like the segments of a LineString. This means "
"that a CircularString must have an odd number of points greater than 1."
msgstr ""
"CIRCULARSTRING은 기본 곡선 유형으로, 선형계의 LINESTRING과 비슷합니다. 단일 "
"분절에는 시작점과 종단점(첫 번째 및 세 번째) 그리고 곡선 위의 다른 한 점 이렇"
"게 포인트 세 개가 필요합니다. 예외는 닫힌 원으로, 이 경우 시작점과 종단점이 "
"동일합니다. 이 경우 두 번째 포인트는 원호의 중심, 즉 원의 반대편이 되어야만 "
"합니다. 원호를 함께 묶으려면, LINESTRING과 마찬가지로 한 원호의 마지막 포인트"
"가 다음 원호의 첫 번째 포인트가 되어야 합니다. 즉 유효한 원형 스트링은 1을 초"
"과하는 홀수 개수의 포인트들을 가져야만 한다는 뜻입니다."

#. Tag: title
#: using_postgis_dataman.xml:237
#, no-c-format
msgid "CompoundCurve"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:238
#, fuzzy, no-c-format
msgid ""
"A CompoundCurve is a single continuous curve that may contain both circular "
"arc segments and linear segments. That means that in addition to having well-"
"formed components, the end point of every component (except the last) must "
"be coincident with the start point of the following component."
msgstr ""
"복심곡선(compound curve)이란 곡선(원호) 분절과 선형 분절이 함께 있는 연속적"
"인 단일 곡선을 말합니다. 즉 구성 요소들이 잘 형성되어야 함은 물론, (마지막을 "
"제외한) 모든 구성 요소의 종단점이 다음 구성 요소의 시작점과 일치해야한 한다"
"는 뜻입니다."

#. Tag: title
#: using_postgis_dataman.xml:247
#, no-c-format
msgid "CurvePolygon"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:248
#, fuzzy, no-c-format
msgid ""
"A CurvePolygon is like a polygon, with an outer ring and zero or more inner "
"rings. The difference is that a ring can be a CircularString or "
"CompoundCurve as well as a LineString."
msgstr ""
"CURVEPOLYGON은 일반 폴리곤입니다. 외곽선과 함께 0개 이상의 내곽선을 가지고 있"
"을 뿐입니다. 차이라면 내외곽선이 원형 스트링, 선형 스트링, 또는 복합 스트링 "
"형태를 할 수 있다는 점입니다."

#. Tag: para
#: using_postgis_dataman.xml:252
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr "PostGIS는 1.4버전부터 만곡 폴리곤에 대해 복심곡선을 지원합니다."

#. Tag: para
#: using_postgis_dataman.xml:256
#, no-c-format
msgid ""
"Example: A CurvePolygon with the shell defined by a CompoundCurve containing "
"a CircularString and a LineString, and a hole defined by a CircularString"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:263
#, no-c-format
msgid "MultiCurve"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:264
#, fuzzy, no-c-format
msgid ""
"A MultiCurve is a collection of curves which can include LineStrings, "
"CircularStrings or CompoundCurves."
msgstr ""
"MULTICURVE는 원형 스트링, 선형 스트링, 복합 스트링을 포함할 수 있는 곡선 집합"
"입니다."

#. Tag: title
#: using_postgis_dataman.xml:270
#, no-c-format
msgid "MultiSurface"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:271
#, fuzzy, no-c-format
msgid ""
"A MultiSurface is a collection of surfaces, which can be (linear) Polygons "
"or CurvePolygons."
msgstr ""
"MULTISURFACE는 면 집합으로, (선형) 폴리곤일 수도 만곡 폴리곤일 수도 있습니다."

#. Tag: title
#: using_postgis_dataman.xml:281
#, fuzzy, no-c-format
msgid "WKT and WKB"
msgstr "OpenGIS WKB 및 WKT"

#. Tag: para
#: using_postgis_dataman.xml:283
#, fuzzy, no-c-format
msgid ""
"The OGC SFA specification defines two formats for representing geometry "
"values for external use: Well-Known Text (WKT) and Well-Known Binary (WKB). "
"Both WKT and WKB include information about the type of the object and the "
"coordinates which define it."
msgstr ""
"OpenGIS사양서에는 공간 오브젝트들을 나타내는 두 가지 표준 방법이 정의되어 있"
"습니다: Well-Known Text (WKT) 형태와 Well-Known Binary (WKB) 형태. WKT와 WKB "
"모두 오브젝트 타입과 오브젝트를 구성하는 좌표들에 대한 정보를 포함하고 있습니"
"다."

#. Tag: para
#: using_postgis_dataman.xml:288
#, fuzzy, no-c-format
msgid ""
"Well-Known Text (WKT) provides a standard textual representation of spatial "
"data. Examples of WKT representations of spatial objects are:"
msgstr ""
"공간 참조 시스템의 WKT(Well-Known Text) 표현식입니다. 다음은 WKT SRS 표현식"
"의 예입니다:"

#. Tag: para
#: using_postgis_dataman.xml:293
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:297
#, fuzzy, no-c-format
msgid "POINT Z (0 0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:301
#, fuzzy, no-c-format
msgid "POINT ZM (0 0 0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:305
#, no-c-format
msgid "POINT EMPTY"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:309
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:313
#, fuzzy, no-c-format
msgid "LINESTRING EMPTY"
msgstr "LINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:317
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:321
#, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:325
#, fuzzy, no-c-format
msgid "MULTIPOINT Z ((0 0 0),(1 2 3))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:329
#, fuzzy, no-c-format
msgid "MULTIPOINT EMPTY"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:333
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:337
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:342
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:346
#, fuzzy, no-c-format
msgid "GEOMETRYCOLLECTION EMPTY"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:350
#, no-c-format
msgid ""
"Input and output of WKT is provided by the functions <xref "
"linkend=\"ST_AsText\"/> and <xref linkend=\"ST_GeomFromText\"/>:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:355
#, fuzzy, no-c-format
msgid ""
"For example, a statement to create and insert a spatial object from WKT and "
"a SRID is:"
msgstr ""
"예를 들어 OGC 공간 객체를 생성하고 삽입하기 위한 유효한 삽입 구문은 다음과 같"
"을 것입니다:"

#. Tag: para
#: using_postgis_dataman.xml:359
#, no-c-format
msgid ""
"Well-Known Binary (WKB) provides a portable, full-precision representation "
"of spatial data as binary data (arrays of bytes). Examples of the WKB "
"representations of spatial objects are:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:365
#, fuzzy, no-c-format
msgid "WKT: POINT(1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:366
#, no-c-format
msgid "WKB: 0101000000000000000000F03F000000000000F03"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:370
#, fuzzy, no-c-format
msgid "WKT: LINESTRING (2 2, 9 9)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:371
#, no-c-format
msgid ""
"WKB: "
"0102000000020000000000000000000040000000000000004000000000000022400000000000002240"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:375
#, no-c-format
msgid ""
"Input and output of WKB is provided by the functions <xref "
"linkend=\"ST_AsBinary\"/> and <xref linkend=\"ST_GeomFromWKB\"/>:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:380
#, fuzzy, no-c-format
msgid ""
"For example, a statement to create and insert a spatial object from WKB is:"
msgstr ""
"예를 들어 OGC 공간 객체를 생성하고 삽입하기 위한 유효한 삽입 구문은 다음과 같"
"을 것입니다:"

#. Tag: title
#: using_postgis_dataman.xml:389
#, no-c-format
msgid "Geometry Data Type"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:391
#, no-c-format
msgid ""
"PostGIS implements the OGC Simple Features model by defining a PostgreSQL "
"data type called <varname>geometry</varname>. It represents all of the "
"geometry subtypes by using an internal type code (see <xref "
"linkend=\"GeometryType\"/> and <xref linkend=\"ST_GeometryType\"/>). This "
"allows modelling spatial features as rows of tables defined with a column of "
"type <varname>geometry</varname>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:399
#, no-c-format
msgid ""
"The <varname>geometry</varname> data type is <emphasis>opaque</emphasis>, "
"which means that all access is done via invoking functions on geometry "
"values. Functions allow creating geometry objects, accessing or updating all "
"internal fields, and compute new geometry values. PostGIS supports all the "
"functions specified in the OGC <ulink url=\"https://portal.ogc.org/files/?"
"artifact_id=25354\"><emphasis>Simple feature access - Part 2: SQL option</"
"emphasis></ulink> (SFS) specification, as well many others. See <xref "
"linkend=\"reference\"/> for the full list of functions."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:410
#, no-c-format
msgid ""
"PostGIS follows the SFA standard by prefixing spatial functions with "
"\"ST_\". This was intended to stand for \"Spatial and Temporal\", but the "
"temporal part of the standard was never developed. Instead it can be "
"interpreted as \"Spatial Type\"."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:417
#, fuzzy, no-c-format
msgid ""
"The SFA standard specifies that spatial objects include a Spatial Reference "
"System identifier (SRID). The SRID is required when creating spatial objects "
"for insertion into the database (it may be defaulted to 0). See <xref "
"linkend=\"ST_SRID\"/> and <xref linkend=\"spatial_ref_sys\"/>"
msgstr ""
"OpenGIS 사양서는 공간 객체의 내부 저장 형식이 공간 참조 시스템 식별자(SRID)"
"를 포함하도록 요구합니다. 데이터베이스에 삽입될 공간 객체 생성시 SRID가 필요"
"합니다."

#. Tag: para
#: using_postgis_dataman.xml:422
#, no-c-format
msgid ""
"To make querying geometry efficient PostGIS defines various kinds of spatial "
"indexes, and spatial operators to use them. See <xref linkend=\"build-"
"indexes\"/> and <xref linkend=\"using-query-indexes\"/> for details."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:428
#, fuzzy, no-c-format
msgid "PostGIS EWKB and EWKT"
msgstr "OpenGIS WKB 및 WKT"

#. Tag: para
#: using_postgis_dataman.xml:430
#, no-c-format
msgid ""
"OGC SFA specifications initially supported only 2D geometries, and the "
"geometry SRID is not included in the input/output representations. The OGC "
"SFA specification 1.2.1 (which aligns with the ISO 19125 standard) adds "
"support for 3D (ZYZ) and measured (XYM and XYZM) coordinates, but still does "
"not include the SRID value."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:436
#, no-c-format
msgid ""
"Because of these limitations PostGIS defined extended EWKB and EWKT formats. "
"They provide 3D (XYZ and XYM) and 4D (XYZM) coordinate support and include "
"SRID information. Including all geometry information allows PostGIS to use "
"EWKB as the format of record (e.g. in DUMP files)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:442
#, no-c-format
msgid ""
"EWKB and EWKT are used for the \"canonical forms\" of PostGIS data objects. "
"For input, the canonical form for binary data is EWKB, and for text data "
"either EWKB or EWKT is accepted. This allows geometry values to be created "
"by casting a text value in either HEXEWKB or EWKT to a geometry value using "
"<varname>::geometry</varname>. For output, the canonical form for binary is "
"EWKB, and for text it is HEXEWKB (hex-encoded EWKB)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid ""
"For example this statement creates a geometry by casting from an EWKT text "
"value, and outputs it using the canonical form of HEXEWKB:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:456
#, no-c-format
msgid "PostGIS EWKT output has a few differences to OGC WKT:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:460
#, no-c-format
msgid "For 3DZ geometries the Z qualifier is omitted:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:461
#, fuzzy, no-c-format
msgid "OGC: POINT Z (1 2 3)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:462
#, fuzzy, no-c-format
msgid "EWKT: POINT (1 2 3)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:465
#, no-c-format
msgid "For 3DM geometries the M qualifier is included:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:466
#, fuzzy, no-c-format
msgid "OGC: POINT M (1 2 3)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:467
#, fuzzy, no-c-format
msgid "EWKT: POINTM (1 2 3)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:470
#, no-c-format
msgid "For 4D geometries the ZM qualifier is omitted:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:471
#, fuzzy, no-c-format
msgid "OGC: POINT ZM (1 2 3 4)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:472
#, fuzzy, no-c-format
msgid "EWKT: POINT (1 2 3 4)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:476
#, no-c-format
msgid ""
"EWKT avoids over-specifying dimensionality and the inconsistencies that can "
"occur with the OGC/ISO format, such as:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:482
#, fuzzy, no-c-format
msgid "POINT ZM (1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:485
#, fuzzy, no-c-format
msgid "POINT ZM (1 1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:488
#, fuzzy, no-c-format
msgid "POINT (1 1 1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:493
#, fuzzy, no-c-format
msgid ""
"PostGIS extended formats are currently a superset of the OGC ones, so that "
"every valid OGC WKB/WKT is also valid EWKB/EWKT. However, this might vary in "
"the future, if the OGC extends a format in a way that conflicts with the "
"PosGIS definition. Thus you SHOULD NOT rely on this compatibility!"
msgstr ""
"PostGIS는 현재 OGC 형식의 상위 집합인 형식을 확장합니다(유효한 모든 WKB/WKT"
"는 유효한 EWKB/EWKT가 됩니다). 하지만 향후 달라질 수도 있습니다. 특히 OGC가 "
"PostGIS 확장 프로그램과 상충하는 새 형식을 들고 나온다면 말입니다. 그러므로 "
"이 피처에 의존해서는 안 됩니다!"

#. Tag: para
#: using_postgis_dataman.xml:500
#, fuzzy, no-c-format
msgid "Examples of the EWKT text representation of spatial objects are:"
msgstr ""
"피쳐들의 공간 오브젝트들의 텍스트 문자열표현들(WKT) 의 예들로는 다음과 같은 "
"것들이 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:504
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:508
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- SRID 추가 XY"

#. Tag: para
#: using_postgis_dataman.xml:512
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:516
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:520
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID 추가 XYM"

#. Tag: para
#: using_postgis_dataman.xml:524
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:529
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:534
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:539
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:543
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:547
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:553
#, fuzzy, no-c-format
msgid "TRIANGLE ((0 0, 0 10, 10 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:557
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: para
#: using_postgis_dataman.xml:562
#, fuzzy, no-c-format
msgid ""
"Input and output using these formats is available using the following "
"functions:"
msgstr "다음과 같은 인터페이스를 이용해서 이 형식을 입력/출력할 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:566
#, fuzzy, no-c-format
msgid ""
"For example, a statement to create and insert a PostGIS spatial object using "
"EWKT is:"
msgstr ""
"예를 들어 PostGIS 공간 객체를 생성하고 삽입하기 위한 유효한 삽입 구문은 다음"
"과 같을 것입니다:"

#. Tag: title
#: using_postgis_dataman.xml:575
#, fuzzy, no-c-format
msgid "Geography Data Type"
msgstr "PostGIS 지리형 유형"

#. Tag: para
#: using_postgis_dataman.xml:577
#, fuzzy, no-c-format
msgid ""
"The PostGIS <varname>geography</varname> data type provides native support "
"for spatial features represented on \"geographic\" coordinates (sometimes "
"called \"geodetic\" coordinates, or \"lat/lon\", or \"lon/lat\"). Geographic "
"coordinates are spherical coordinates expressed in angular units (degrees)."
msgstr ""
"지리형 유형은 (종종 \"측지\" 좌표, 또는 \"위도/경도\"나 \"경도/위도\"라고 불"
"리는) \"지리\" 좌표로 표현되는 공간 피처를 자체적으로 지원합니다. 지리 좌표"
"는 각도 단위(도)를 사용하는 구면(球面) 좌표입니다."

#. Tag: para
#: using_postgis_dataman.xml:579
#, fuzzy, no-c-format
msgid ""
"The basis for the PostGIS geometry data type is a plane. The shortest path "
"between two points on the plane is a straight line. That means functions on "
"geometries (areas, distances, lengths, intersections, etc) are calculated "
"using straight line vectors and cartesian mathematics. This makes them "
"simpler to implement and faster to execute, but also makes them inaccurate "
"for data on the spheroidal surface of the earth."
msgstr ""
"PostGIS 도형 유형은 평면을 기반으로 합니다. 평면상에서 두 포인트 사이의 가장 "
"짧은 경로는 직선입니다. 즉 데카르트 수학과 직선 벡터를 이용해서 도형에 대해 "
"계산(면적, 거리, 길이, 교차점 등)한다는 뜻입니다."

#. Tag: para
#: using_postgis_dataman.xml:587
#, fuzzy, no-c-format
msgid ""
"The PostGIS geography data type is based on a spherical model. The shortest "
"path between two points on the sphere is a great circle arc. Functions on "
"geographies (areas, distances, lengths, intersections, etc) are calculated "
"using arcs on the sphere. By taking the spheroidal shape of the world into "
"account, the functions provide more accurate results."
msgstr ""
"PostGIS 지리형 유형은 구면을 기반으로 합니다. 구면상에서 두 포인트 사이의 가"
"장 짧은 경로는 대권(大圈; great circle arc)입니다. 즉 지리형에 대한 계산(면"
"적, 거리, 길이, 교차점 등)은 더 복잡한 수학을 이용해서 구면상에서 이루어져야 "
"한다는 뜻입니다. 더 정확하게 측정하려면 지구의 실제 회전타원체(spheroidal "
"shape)를 고려해서 계산해야 하는데, 수학이 아주 복잡해질 수밖에 없습니다."

#. Tag: para
#: using_postgis_dataman.xml:592
#, fuzzy, no-c-format
msgid ""
"Because the underlying mathematics is more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added the capabilities of the geography type "
"will expand. As a workaround one can convert back and forth between geometry "
"and geography types."
msgstr ""
"기저 수학이 훨씬 더 복잡하기 때문에, 지리형 유형을 위해 정의된 함수는 도형 유"
"형의 함수보다 더 적습니다. 시간이 지날수록 새 알고리즘이 추가되어 지리형 유형"
"의 역량은 확장될 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:596
#, no-c-format
msgid ""
"Like the geometry data type, geography data is associated with a spatial "
"reference system via a spatial reference system identifier (SRID). Any "
"geodetic (long/lat based) spatial reference system defined in the "
"<varname>spatial_ref_sys</varname> table can be used. (Prior to PostGIS 2.2, "
"the geography type supported only WGS 84 geodetic (SRID:4326)). You can add "
"your own custom geodetic spatial reference system as described in <xref "
"linkend=\"user-spatial-ref-sys\"/>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:602
#, no-c-format
msgid ""
"For all spatial reference systems the units returned by measurement "
"functions (e.g. <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_Length\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Area\"/>) and for "
"the distance argument of <xref linkend=\"ST_DWithin\"/> are in meters."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:607
#, fuzzy, no-c-format
msgid "Creating Geography Tables"
msgstr "공간 테이블 생성"

#. Tag: para
#: using_postgis_dataman.xml:609
#, no-c-format
msgid ""
"You can create a table to store geography data using the <ulink "
"url=\"https://www.postgresql.org/docs/current/sql-createtable.html\">CREATE "
"TABLE</ulink> SQL statement with a column of type <varname>geography</"
"varname>. The following example creates a table with a geography column "
"storing 2D LineStrings in the WGS84 geodetic coordinate system (SRID 4326):"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:617
#, no-c-format
msgid "The geography type supports two optional type modifiers:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:621
#, fuzzy, no-c-format
msgid ""
"the spatial type modifier restricts the kind of shapes and dimensions "
"allowed in the column. Values allowed for the spatial type are: POINT, "
"LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, "
"GEOMETRYCOLLECTION. The geography type does not support curves, TINS, or "
"POLYHEDRALSURFACEs. The modifier supports coordinate dimensionality "
"restrictions by adding suffixes: Z, M and ZM. For example, a modifier of "
"'LINESTRINGM' only allows linestrings with three dimensions, and treats the "
"third dimension as a measure. Similarly, 'POINTZM' requires four dimensional "
"(XYZM) data."
msgstr ""
"유형 변경자가 허용하는 값은 다음과 같습니다. POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. 또 이 변경자는 Z, M 및 ZM이라는 접"
"미사를 통해 차원수 제약도 지원합니다. 따라서, 예를 들자면 'LINESTRINGM'의 변"
"경자는 3차원 이하의 라인 스트링만을 허용할 것이며, 세 번째 차원을 기준으로 취"
"급할 것입니다. 마찬가지로 'POINTZM'은 네 가지 차원의 데이터를 입력해야 할 것"
"입니다."

#. Tag: para
#: using_postgis_dataman.xml:630
#, no-c-format
msgid ""
"the SRID modifier restricts the spatial reference system SRID to a "
"particular number. If omitted, the SRID defaults to 4326 (WGS84 geodetic), "
"and all calculations are performed using WGS84."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:638
#, no-c-format
msgid "Examples of creating tables with geography columns:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:641
#, fuzzy, no-c-format
msgid ""
"Create a table with 2D POINT geography with the default SRID 4326 (WGS84 "
"long/lat):"
msgstr "POINT: 2D 포인트 도형을 담은 테이블 생성:"

#. Tag: para
#: using_postgis_dataman.xml:645
#, fuzzy, no-c-format
msgid "Create a table with 2D POINT geography in NAD83 longlat:"
msgstr "POINT: 2D 포인트 도형을 담은 테이블 생성:"

#. Tag: para
#: using_postgis_dataman.xml:649
#, no-c-format
msgid "Create a table with 3D (XYZ) POINTs and an explicit SRID of 4326:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:653
#, no-c-format
msgid "Create a table with 2D LINESTRING geography with the default SRID 4326:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:657
#, fuzzy, no-c-format
msgid ""
"Create a table with 2D POLYGON geography with the SRID 4267 (NAD 1927 long "
"lat):"
msgstr "POINT: 2D 포인트 도형을 담은 테이블 생성:"

#. Tag: para
#: using_postgis_dataman.xml:676
#, no-c-format
msgid ""
"Geography fields are registered in the <varname>geography_columns</varname> "
"system view. You can query the <varname>geography_columns</varname> view and "
"see that the table is listed:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:681
#, fuzzy, no-c-format
msgid ""
"Creating a spatial index works the same as for geometry columns. PostGIS "
"will note that the column type is GEOGRAPHY and create an appropriate sphere-"
"based index instead of the usual planar index used for GEOMETRY."
msgstr ""
"도형과 동일한 방법으로 인덱스를 생성합니다. PostGIS가 열 유형이 지리형인 것"
"을 감지하고 일반적인 도형 용 평면 인덱스 대신 적절한 구면 기반 인덱스를 생성"
"할 것입니다."

#. Tag: title
#: using_postgis_dataman.xml:689
#, fuzzy, no-c-format
msgid "Using Geography Tables"
msgstr "PostGIS 지리형 유형"

#. Tag: para
#: using_postgis_dataman.xml:691
#, no-c-format
msgid ""
"You can insert data into geography tables in the same way as geometry. "
"Geometry data will autocast to the geography type if it has SRID 4326. The "
"<link linkend=\"EWKB_EWKT\">EWKT and EWKB</link> formats can also be used to "
"specify geography values."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:698
#, no-c-format
msgid ""
"Any geodetic (long/lat) spatial reference system listed in "
"<varname>spatial_ref_sys</varname> table may be specified as a geography "
"SRID. Non-geodetic coordinate systems raise an error if used."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:709
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"쿼리 및 측정 함수는 미터 단위를 사용합니다. 따라서 거리 파라미터는 미터로 표"
"현되어야 하고, 반환값도 미터(또는 면적의 경우 평방미터) 단위가 될 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:714
#, fuzzy, no-c-format
msgid ""
"You can see the power of geography in action by calculating how close a "
"plane flying a great circle route from Seattle to London (LINESTRING(-122.33 "
"47.606, 0.0 51.5)) comes to Reykjavik (POINT(-21.96 64.15)) (<ulink "
"url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">map the route</ulink>)."
msgstr ""
"시애틀에서 런던으로 가는 비행기가(LINESTRING(-122.33 47.606, 0.0 51.5)) 레이"
"캬비크에(POINT(-21.96 64.15)) 얼마나 접근하는지 계산해보면, 실제 계산시 지리"
"형이 얼마나 강력한지 알 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:720
#, fuzzy, no-c-format
msgid ""
"The geography type calculates the true shortest distance of 122.235 km over "
"the sphere between Reykjavik and the great circle flight path between "
"Seattle and London."
msgstr ""
"지리형 유형이 시애틀과 런던을 잇는 대권항로와 레이캬비크 사이의 구면 상 가장 "
"짧은 거리를 실제로 계산할 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:725
#, fuzzy, no-c-format
msgid ""
"The geometry type calculates a meaningless cartesian distance between "
"Reykjavik and the straight line path from Seattle to London plotted on a "
"flat map of the world. The nominal units of the result is \"degrees\", but "
"the result doesn't correspond to any true angular difference between the "
"points, so even calling them \"degrees\" is inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">대권 매퍼(Great "
"Circle mapper)</ulink> 도형 유형은 평면 세계지도 상에서 시애틀과 런던을 직선"
"으로 잇는 경로와 레이캬비크 사이의 아무 의미도 없는 데카르트 거리를 계산합니"
"다. 결과값의 명목상 단위를 \"도(degree)\"라고 할 수도 있겠지만, 결과값은 세 "
"포인트 사이의 어떤 실제 각도 차이도 반영하지 않기 때문에 \"도\"라고 하는 것조"
"차 부정확한 일이 됩니다."

#. Tag: title
#: using_postgis_dataman.xml:737
#, fuzzy, no-c-format
msgid "When to use the Geography data type"
msgstr "도형 데이터 유형과 지리형 데이터 유형을 중첩해서 이용하는 경우"

#. Tag: para
#: using_postgis_dataman.xml:738
#, fuzzy, no-c-format
msgid ""
"The geography data type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""
"새로운 지리형 유형은 데이터를 경도/위도 좌표로 저장할 수 있도록 해주지만, 단"
"점도 있습니다. 도형을 대상으로 정의된 함수보다 지리형 대상 함수가 더 적고, "
"그 정의된 함수도 실행하는 데 CPU 시간을 더 많이 잡아먹습니다."

#. Tag: para
#: using_postgis_dataman.xml:739
#, fuzzy, no-c-format
msgid ""
"The data type you choose should be determined by the expected working area "
"of the application you are building. Will your data span the globe or a "
"large continental area, or is it local to a state, county or municipality?"
msgstr ""
"사용자가 선택한 유형은 사용자가 빌드하는 응용 프로그램 영역에서 기대한대로 동"
"작하도록 적합한 조건을 갖춰야 합니다. 사용자 데이터가 전세계 또는 광대한 대"
"륙 지역을 포괄할 예정입니까 아니면 시, 도, 군 또는 그 이하의 지자체에 국한될 "
"예정입니까?"

#. Tag: para
#: using_postgis_dataman.xml:741
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"사용자 데이터가 좁은 지역에 국한된다면, 사용 가능한 실행성 및 기능성 관점에"
"서, 적합한 투영을 선택하고 도형을 이용하는 것이 최선의 해결책이 될 수도 있습"
"니다."

#. Tag: para
#: using_postgis_dataman.xml:742
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"사용자 데이터가 전세계 또는 대륙에 걸쳐 있을 경우, 지리형을 이용하면 일일이 "
"어떤 투영법을 이용할지 고민하지 않고 시스템을 빌드할 수도 있습니다. 사용자 데"
"이터를 경도/위도로 저장하고, 지리형을 대상으로 정의된 함수를 이용하십시오."

#. Tag: para
#: using_postgis_dataman.xml:744
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"투영에 대한 이해가 부족하고, 따로 공부하고 싶지도 않으며, 지리형 사용시 기능"
"성이 제한된다는 사실을 받아들일 준비가 되어 있다면, 도형보다 지리형을 사용하"
"는 편이 더 쉬울 수 있습니다. 그냥 사용자 데이터를 경도/위도로 로드한 다음 작"
"업을 시작하십시오."

#. Tag: para
#: using_postgis_dataman.xml:747
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref "
"linkend=\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"지리형과 도형을 각각 지원하는 함수를 비교해보려면 <xref "
"linkend=\"PostGIS_TypeFunctionMatrix\"/> 를 참조하십시오. 지리형 함수의 목록 "
"및 설명을 간단하게 살펴보려면 <xref linkend=\"PostGIS_GeographyFunctions\"/> "
"를 참조하십시오."

#. Tag: title
#: using_postgis_dataman.xml:753
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "지리형 고급 FAQ"

#. Tag: para
#: using_postgis_dataman.xml:757
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "계산 작업시 구체 상에서 계산하게 됩니까 회전타원체 상에서 하게 됩니까?"

#. Tag: para
#: using_postgis_dataman.xml:761
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"기본적으로, 모든 거리 및 면적 계산은 회전타원체 상에서 이루어집니다. 좁은 지"
"역을 대상으로 한 계산의 결과와 해당 지역에 적절한 투영법을 적용한 평면 상 계"
"산 결과는 일치할 것입니다. 더 넓은 지역이라면 투영법을 적용한 평면 상 계산보"
"다 회전타원체 상 계산이 언제나 더 정확할 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:764
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"최종 불 파라미터 'FALSE'를 설정하면 모든 지리형 함수가 구체 상 계산을 할 수 "
"있습니다. 이렇게 하면 계산 속도가 조금 빨라질 것입니다. 특히 도형들이 매우 단"
"순한 경우에 말입니다."

#. Tag: para
#: using_postgis_dataman.xml:770
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "날짜변경선과 남극/북극은 어떻습니까?"

#. Tag: para
#: using_postgis_dataman.xml:774
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"모든 계산은 날짜변경선이나 양극을 고려하지 않고 이루어집니다. 좌표가 회전타원"
"체(경도/위도)이기 때문에 날짜변경선을 지나는 형상이라도, 계산이라는 관점에서 "
"보면, 다른 어떤 형상과도 다를 바가 없습니다."

#. Tag: para
#: using_postgis_dataman.xml:782
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "공간 처리할 수 있는 가장 긴 원호가 무엇인가요?"

#. Tag: para
#: using_postgis_dataman.xml:786
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"두 포인트 사이의 \"보간 라인\"으로 대권호(great circle arc)를 이용합니다. 즉 "
"대권을 따라 어느 방향으로 이동하느냐에 따라 두 포인트가 실제로는 두 가지 방식"
"으로 만난다는 뜻입니다. 모든 코드는 포인트들이 대권을 따라 가는 두 경로 가운"
"데 '짧은' 경로로 만난다고 가정합니다. 결과적으로, 180도 이상의 원호를 가진다"
"면 정확히 모델링된 형상이 아니게 됩니다."

#. Tag: para
#: using_postgis_dataman.xml:793
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"유럽이나 러시아의 면적을 계산하거나 또는 광대한 지역을 삽입하는 작업이 이렇"
"게 느린 이유가 뭐지요?"

#. Tag: para
#: using_postgis_dataman.xml:797
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"폴리곤이 너무나 크기 때문이지요! 광대한 지역은 두 가지 이유로 좋지 않습니다. "
"먼저 경계가 워낙 길기 때문에 어떤 쿼리를 실행하든 인덱스가 피처 전체를 읽어오"
"는 경향이 있습니다. 그리고 꼭짓점 개수도 너무 많아서 거리, 밀폐 여부 등의 테"
"스트를 할 때 적어도 한 번, 때로는 n번 이상(이때 n은 다른 후보 피처의 꼭짓점 "
"개수) 꼭짓점 목록 전체를 훑어야 하기 때문입니다."

#. Tag: para
#: using_postgis_dataman.xml:802
#, fuzzy, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Please consult <xref linkend=\"ST_Subdivide\"/> function documentation. Just "
"because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""
"도형의 경우, 대용량 폴리곤을 대상으로 좁은 지역에 대한 쿼리를 할 때 사용자 도"
"형 데이터를 더 작은 덩어리들로 \"비정규화\"해서 인덱스가 효율적으로 객체의 일"
"부분을 하위 쿼리(subquery)할 수 있도록 만들어 쿼리 시 매번 전체 객체를 읽어"
"올 필요가 없도록 하는 편이 좋습니다. 유럽 전체를 폴리곤 한 개로 저장할 수 있"
"다고 해서 꼭 그렇게 해야 한다는 뜻은 아닙니다."

#. Tag: title
#: using_postgis_dataman.xml:811
#, no-c-format
msgid "Geometry Validation"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:813
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) Simple "
"Features specification. That standard defines the concepts of geometry being "
"<emphasis>simple</emphasis> and <emphasis>valid</emphasis>. These "
"definitions allow the Simple Features geometry model to represent spatial "
"objects in a consistent and unambiguous way that supports efficient "
"computation. (Note: the OGC SF and SQL/MM have the same definitions for "
"simple and valid.)"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:824
#, no-c-format
msgid "Simple Geometry"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:826
#, no-c-format
msgid ""
"A <emphasis>simple</emphasis> geometry is one that has no anomalous "
"geometric points, such as self intersection or self tangency."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:831
#, fuzzy, no-c-format
msgid ""
"A <varname>POINT</varname> is inherently <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"<varname>POINT</varname> 란 0차원 도형 객체로서 상속적으로 <emphasis>단순형</"
"emphasis> 입니다."

#. Tag: para
#: using_postgis_dataman.xml:834
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname> 는 어떤 두 좌표(<varname>POINT</varname>)도 동"
"일하지 않은 (동일한 좌표를 공유하지 않는) <emphasis>단순형</emphasis> 입니다."

#. Tag: para
#: using_postgis_dataman.xml:838
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same point twice, except for the endpoints. If the "
"endpoints of a simple LineString are identical it is called "
"<emphasis>closed</emphasis> and referred to as a Linear Ring."
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:847
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s. <emphasis "
"role=\"bold\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are "
"not simple. <emphasis role=\"bold\">(c)</emphasis> is a closed Linear Ring."
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:865
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:875
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:887
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:897
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:906
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at points that are on the boundaries of both elements."
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:915
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s. <emphasis "
"role=\"bold\">(g)</emphasis> is not simple."
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:933
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:943
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:953
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:961
#, no-c-format
msgid ""
"<varname>POLYGON</varname>s are formed from linear rings, so valid polygonal "
"geometry is always <emphasis>simple</emphasis>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:964
#, no-c-format
msgid ""
"To test if a geometry is simple use the <xref linkend=\"ST_IsSimple\"/> "
"function:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:969
#, no-c-format
msgid ""
"Generally, PostGIS functions do not require geometric arguments to be "
"simple. Simplicity is primarily used as a basis for defining geometric "
"validity. It is also a requirement for some kinds of spatial data models "
"(for example, linear networks often disallow lines that cross). Multipoint "
"and linear geometry can be made simple using <xref linkend=\"ST_UnaryUnion\"/"
">."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:978
#, no-c-format
msgid "Valid Geometry"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:980
#, no-c-format
msgid ""
"Geometry validity primarily applies to 2-dimensional geometries "
"(<varname>POLYGON</varname>s and <varname>MULTIPOLYGON</varname>s) . "
"Validity is defined by rules that allow polygonal geometry to model planar "
"areas unambiguously."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:986
#, no-c-format
msgid "A <varname>POLYGON</varname> is <emphasis>valid</emphasis> if:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:990
#, no-c-format
msgid ""
"the polygon boundary rings (the exterior shell ring and interior hole rings) "
"are <emphasis>simple</emphasis> (do not cross or self-touch). Because of "
"this a polygon cannnot have cut lines, spikes or loops. This implies that "
"polygon holes must be represented as interior rings, rather than by the "
"exterior ring self-touching (a so-called \"inverted hole\")."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:997
#, no-c-format
msgid "boundary rings do not cross"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1000
#, no-c-format
msgid ""
"boundary rings may touch at points but only as a tangent (i.e. not in a line)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1003
#, no-c-format
msgid "interior rings are contained in the exterior ring"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1006
#, no-c-format
msgid ""
"the polygon interior is simply connected (i.e. the rings must not touch in a "
"way that splits the polygon into more than one part)"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1016
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s. <emphasis role=\"bold\">(j-"
"m)</emphasis> are invalid. <emphasis role=\"bold\">(j)</emphasis> can be "
"represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1035
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1045
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1055
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1067
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1077
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1087
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1095
#, no-c-format
msgid "A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1099
#, no-c-format
msgid "its element <varname>POLYGON</varname>s are valid"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1102
#, no-c-format
msgid "elements do not overlap (i.e. their interiors must not intersect)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1105
#, no-c-format
msgid "elements touch only at points (i.e. not along a line)"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1114
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> is a valid <varname>MULTIPOLYGON</"
"varname>. <emphasis role=\"bold\">(o)</emphasis> and <emphasis "
"role=\"bold\">(p)</emphasis> are invalid."
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1130
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1140
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1150
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1158
#, no-c-format
msgid ""
"These rules mean that valid polygonal geometry is also <emphasis>simple</"
"emphasis>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1161
#, no-c-format
msgid ""
"For linear geometry the only validity rule is that <varname>LINESTRING</"
"varname>s must have at least two points and have non-zero length (or "
"equivalently, have at least two distinct points.) Note that non-simple (self-"
"intersecting) lines are valid."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1169
#, no-c-format
msgid ""
"<varname>POINT</varname> and <varname>MULTIPOINT</varname> geometries have "
"no validity rules."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1175
#, no-c-format
msgid "Managing Validity"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1177
#, no-c-format
msgid ""
"PostGIS allows creating and storing both valid and invalid Geometry. This "
"allows invalid geometry to be detected and flagged or fixed. There are also "
"situations where the OGC validity rules are stricter than desired (examples "
"of this are zero-length linestrings and polygons with inverted holes.)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1183
#, no-c-format
msgid ""
"Many of the functions provided by PostGIS rely on the assumption that "
"geometry arguments are valid. For example, it does not make sense to "
"calculate the area of a polygon that has a hole defined outside of the "
"polygon, or to construct a polygon from a non-simple boundary line. Assuming "
"valid geometric inputs allows functions to operate more efficiently, since "
"they do not need to check for topological correctness. (Notable exceptions "
"are that zero-length lines and polygons with inversions are generally "
"handled correctly.) Also, most PostGIS functions produce valid geometry "
"output if the inputs are valid. This allows PostGIS functions to be chained "
"together safely."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1196
#, no-c-format
msgid ""
"If you encounter unexpected error messages when calling PostGIS functions "
"(such as \"GEOS Intersection() threw an error!\"), you should first confirm "
"that the function arguments are valid. If they are not, then consider using "
"one of the techniques below to ensure the data you are processing is valid."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1203
#, no-c-format
msgid ""
"If a function reports an error with valid inputs, then you may have found an "
"error in either PostGIS or one of the libraries it uses, and you should "
"report this to the PostGIS project. The same is true if a PostGIS function "
"returns an invalid geometry for valid input."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1210
#, no-c-format
msgid ""
"To test if a geometry is valid use the <xref linkend=\"ST_IsValid\"/> "
"function:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1214
#, no-c-format
msgid ""
"Information about the nature and location of an geometry invalidity are "
"provided by the <xref linkend=\"ST_IsValidDetail\"/> function:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1219
#, no-c-format
msgid ""
"In some situations it is desirable to correct invalid geometry "
"automatically. Use the <xref linkend=\"ST_MakeValid\"/> function to do this. "
"(<code>ST_MakeValid</code> is a case of a spatial function that "
"<emphasis>does</emphasis> allow invalid input!)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1224
#, no-c-format
msgid ""
"By default, PostGIS does not check for validity when loading geometry, "
"because validity testing can take a lot of CPU time for complex geometries. "
"If you do not trust your data sources, you can enforce a validity check on "
"your tables by adding a check constraint:"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1236
#, fuzzy, no-c-format
msgid "Spatial Reference Systems"
msgstr "SPATIAL_REF_SYS 테이블과 공간 참조 시스템"

#. Tag: para
#: using_postgis_dataman.xml:1238
#, no-c-format
msgid ""
"A <ulink url=\"https://en.wikipedia.org/wiki/"
"Spatial_reference_system\">Spatial Reference System</ulink> (SRS) (also "
"called a Coordinate Reference System (CRS)) defines how geometry is "
"referenced to locations on the Earth's surface. There are three types of SRS:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1244
#, no-c-format
msgid ""
"A <emphasis role=\"bold\">geodetic</emphasis> SRS uses angular coordinates "
"(longitude and latitude) which map directly to the surface of the earth."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1247
#, no-c-format
msgid ""
"A <emphasis role=\"bold\">projected</emphasis> SRS uses a mathematical "
"projection transformation to \"flatten\" the surface of the spheroidal earth "
"onto a plane. It assigns location coordinates in a way that allows direct "
"measurement of quantities such as distance, area, and angle. The coordinate "
"system is Cartesian, which means it has a defined origin point and two "
"perpendicular axes (usually oriented North and East). Each projected SRS "
"uses a stated length unit (usually metres or feet). A projected SRS may be "
"limited in its area of applicability to avoid distortion and fit within the "
"defined coordinate bounds."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1258
#, no-c-format
msgid ""
"A <emphasis role=\"bold\">local</emphasis> SRS is a Cartesian coordinate "
"system which is not referenced to the earth's surface. In PostGIS this is "
"specified by a SRID value of 0."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1263
#, no-c-format
msgid ""
"There are many different spatial reference systems in use. Common SRSes are "
"standardized in the European Petroleum Survey Group <ulink url=\"http://www."
"epsg.org/\">EPSG database</ulink>. For convenience PostGIS (and many other "
"spatial systems) refers to SRS definitions using an integer identifier "
"called a SRID."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1272
#, no-c-format
msgid ""
"A geometry is associated with a Spatial Reference System by its SRID value, "
"which is accessed by <xref linkend=\"ST_SRID\"/>. The SRID for a geometry "
"can be assigned using <xref linkend=\"ST_SetSRID\"/>. Some geometry "
"constructor functions allow supplying a SRID (such as <xref "
"linkend=\"ST_Point\"/> and <xref linkend=\"ST_MakeEnvelope\"/>). The <link "
"linkend=\"EWKB_EWKT\">EWKT</link> format supports SRIDs with the "
"<code>SRID=n;</code> prefix."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1280
#, no-c-format
msgid ""
"Spatial functions processing pairs of geometries (such as <link "
"linkend=\"Overlay_Functions\">overlay</link> and <link "
"linkend=\"Spatial_Relationships\">relationship</link> functions) require "
"that the input geometries are in the same spatial reference system (have the "
"same SRID). Geometry data can be transformed into a different spatial "
"reference system using <xref linkend=\"ST_Transform\"/> and <xref "
"linkend=\"ST_TransformPipeline\"/>. Geometry returned from functions has the "
"same SRS as the input geometries."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1291
#, no-c-format
msgid "SPATIAL_REF_SYS Table"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1293
#, no-c-format
msgid ""
"The <varname>SPATIAL_REF_SYS</varname> table used by PostGIS is an OGC-"
"compliant database table that defines the available spatial reference "
"systems. It holds the numeric SRIDs and textual descriptions of the "
"coordinate systems."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1299
#, fuzzy, no-c-format
msgid "The <varname>spatial_ref_sys</varname> table definition is:"
msgstr "<varname>SPATIAL_REF_SYS</varname> 테이블 정의는 다음과 같습니다:"

#. Tag: para
#: using_postgis_dataman.xml:1303 using_postgis_dataman.xml:1514
#, fuzzy, no-c-format
msgid "The columns are:"
msgstr "다음과 같은 명령행 옵션이 있습니다:"

#. Tag: term
#: using_postgis_dataman.xml:1307 using_postgis_dataman.xml:1545
#, no-c-format
msgid "srid"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1310
#, fuzzy, no-c-format
msgid ""
"An integer code that uniquely identifies the <ulink url=\"http://en."
"wikipedia.org/wiki/SRID\">Spatial Reference System</ulink> (SRS) within the "
"database."
msgstr ""
"데이터베이스 내부에서 공간 참조 시스템(SRS)을 고유하게 식별하는 정수값입니다."

#. Tag: term
#: using_postgis_dataman.xml:1316
#, no-c-format
msgid "auth_name"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1319
#, fuzzy, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" is a valid <varname>auth_name</"
"varname>."
msgstr ""
"해당 참조 시스템을 위해 인용되는 표준 또는 표준들 본체의 명칭입니다. 예를 들"
"어 \"EPSG\"는 유효한 <varname>AUTH_NAME</varname> 이라고 할 수 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1326
#, no-c-format
msgid "auth_srid"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1329
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>auth_name</varname>. In the case of EPSG, this is the EPSG code."
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1336
#, no-c-format
msgid "srtext"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1339
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"공간 참조 시스템의 WKT(Well-Known Text) 표현식입니다. 다음은 WKT SRS 표현식"
"의 예입니다:"

#. Tag: para
#: using_postgis_dataman.xml:1344
#, no-c-format
msgid ""
"For a discussion of SRS WKT, see the OGC standard <ulink url=\"http://docs."
"opengeospatial.org/is/12-063r5/12-063r5.html\">Well-known text "
"representation of coordinate reference systems</ulink>."
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1351
#, no-c-format
msgid "proj4text"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1354
#, fuzzy, no-c-format
msgid ""
"PostGIS uses the PROJ library to provide coordinate transformation "
"capabilities. The <varname>proj4text</varname> column contains the PROJ "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"PostGIS는 좌표 변환 기능을 제공하기 위해 proj4 라이브러리를 이용합니다. "
"<varname>PROJ4TEXT</varname> 열이 특정 SRID에 대응하는 proj4 좌펴 정의 스트링"
"을 담고 있습니다. 다음은 그 예입니다:"

#. Tag: para
#: using_postgis_dataman.xml:1361
#, fuzzy, no-c-format
msgid ""
"For more information see the <ulink url=\"https://proj.org/\">PROJ web site</"
"ulink>. The <filename>spatial_ref_sys.sql</filename> file contains both "
"<varname>srtext</varname> and <varname>proj4text</varname> definitions for "
"all EPSG projections."
msgstr ""
"이에 대한 자세한 정보는 <ulink url=\"http://trac.osgeo.org/proj/\">http://"
"trac.osgeo.org/proj/</ulink> 주소의 proj4 웹사이트를 참조하십시오. "
"<filename>spatial_ref_sys.sql</filename> 파일이 모든 EPSG 투영에 대한 "
"<varname>SRTEXT</varname> 및 <varname>PROJ4TEXT</varname> 정의를 담고 있습니"
"다."

#. Tag: para
#: using_postgis_dataman.xml:1370
#, no-c-format
msgid ""
"When retrieving spatial reference system definitions for use in "
"transformations, PostGIS uses fhe following strategy:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1374
#, no-c-format
msgid ""
"If <varname>auth_name</varname> and <varname>auth_srid</varname> are present "
"(non-NULL) use the PROJ SRS based on those entries (if one exists)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1378
#, no-c-format
msgid ""
"If <varname>srtext</varname> is present create a SRS using it, if possible."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1381
#, no-c-format
msgid ""
"If <varname>proj4text</varname> is present create a SRS using it, if "
"possible."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1387
#, fuzzy, no-c-format
msgid "User-Defined Spatial Reference Systems"
msgstr "SPATIAL_REF_SYS 테이블과 공간 참조 시스템"

#. Tag: para
#: using_postgis_dataman.xml:1389
#, fuzzy, no-c-format
msgid ""
"The PostGIS <varname>spatial_ref_sys</varname> table contains over 3000 of "
"the most common spatial reference system definitions that are handled by the "
"<ulink url=\"https://proj.org\">PROJ</ulink> projection library. But there "
"are many coordinate systems that it does not contain. You can add SRS "
"definitions to the table if you have the required information about the "
"spatial reference system. Or, you can define your own custom spatial "
"reference system if you are familiar with PROJ constructs. Keep in mind that "
"most spatial reference systems are regional and have no meaning when used "
"outside of the bounds they were intended for."
msgstr ""
"PostGIS의 <varname>SPATIAL_REF_SYS</varname> 테이블이 proj 라이브러리가 처리"
"할 수 있는, 좀 더 널리 사용되는 공간 참조 시스템 3000여 개를 담고 있긴 하지"
"만 현재까지 알려진 모든 공간 참조 시스템을 다 담고 있지는 않으며, 사용자가 "
"proj4의 구조를 잘 알고 있다면 자기만의 사용자 지정 투영을 정의할 수도 있습니"
"다. 공간 참조 시스템 대부분은 특정 지역에 특화되어 있으며, 특화된 지역 범위 "
"바깥에서 사용할 경우 어떤 의미도 없다는 점을 명심하십시오."

#. Tag: para
#: using_postgis_dataman.xml:1399
#, fuzzy, no-c-format
msgid ""
"A resource for finding spatial reference systems not defined in the core set "
"is <ulink url=\"http://spatialreference.org/\">http://spatialreference.org/</"
"ulink>"
msgstr ""
"핵심 <varname>SPATIAL_REF_SYS</varname> 테이블에 정의되지 않은 공간 참조 시스"
"템은 <ulink url=\"http://spatialreference.org/\">http://spatialreference.org/"
"</ulink> 에 훌륭하게 정리되어 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1401
#, fuzzy, no-c-format
msgid ""
"Some commonly used spatial reference systems are: <ulink url=\"http://"
"spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD 83 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS "
"84 World Mercator</ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/2163/\">2163 - US National Atlas Equal Area</ulink>, and the 60 WGS84 "
"UTM zones. UTM zones are one of the most ideal for measurement, but only "
"cover 6-degree regions. (To determine which UTM zone to use for your area of "
"interest, see the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>.)"
msgstr ""
"좀 더 널리 사용되는 공간 참조 시스템에는 <ulink url=\"http://"
"spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD 83 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS "
"84 World Mercator</ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/2163/\">2163 - US National Atlas Equal Area</ulink>, 그리고 NAD 83 및 "
"WGS 84 UTM 대(帶; zone)의 공간 참조 시스템이 있습니다. 각 UTM 대는 측정에 가"
"장 이상적인 공간 참조 시스템이지만, 6도 범위의 지역에만 특화되어 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1410
#, fuzzy, no-c-format
msgid ""
"US states use State Plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per state. Most of the meter-based ones are in the "
"core set, but many of the feet-based ones or ESRI-created ones will need to "
"be copied from <ulink url=\"http://spatialreference.org\">spatialreference."
"org</ulink>."
msgstr ""
"미국 여러 주의 평면 공간 참조 시스템(미터 또는 피트 기반)은 각 주마다 보통 "
"한 개 또는 두 개가 존재합니다. 미터 기반 공간 참조 시스템 대부분은 "
"<varname>SPATIAL_REF_SYS</varname> 테이블에 들어 있지만, 피트 기반 또는 ESRI"
"가 생성한 공간 참조 시스템 중 상당수는 사용자가 <ulink url=\"http://"
"spatialreference.org\">spatialreference.org</ulink> 에서 찾아와야 합니다."

#. Tag: para
#: using_postgis_dataman.xml:1416
#, no-c-format
msgid ""
"You can even define non-Earth-based coordinate systems, such as <ulink "
"url=\"http://spatialreference.org/ref/iau2000/mars-2000/\">Mars 2000</ulink> "
"This Mars coordinate system is non-planar (it's in degrees spheroidal), but "
"you can use it with the <varname>geography</varname> type to obtain length "
"and proximity measurements in meters instead of degrees."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1422
#, no-c-format
msgid ""
"Here is an example of loading a custom coordinate system using an unassigned "
"SRID and the PROJ definition for a US-centric Lambert Conformal projection:"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1432
#, fuzzy, no-c-format
msgid "Spatial Tables"
msgstr "공간 테이블 생성"

#. Tag: title
#: using_postgis_dataman.xml:1435
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "공간 테이블 생성"

#. Tag: para
#: using_postgis_dataman.xml:1437
#, no-c-format
msgid ""
"You can create a table to store geometry data using the <ulink url=\"https://"
"www.postgresql.org/docs/current/sql-createtable.html\">CREATE TABLE</ulink> "
"SQL statement with a column of type <varname>geometry</varname>. The "
"following example creates a table with a geometry column storing 2D (XY) "
"LineStrings in the BC-Albers coordinate system (SRID 3005):"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1445
#, no-c-format
msgid ""
"The <varname>geometry</varname> type supports two optional <emphasis "
"role=\"bold\">type modifiers</emphasis>:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1449
#, fuzzy, no-c-format
msgid ""
"the <emphasis role=\"bold\">spatial type modifier</emphasis> restricts the "
"kind of shapes and dimensions allowed in the column. The value can be any of "
"the supported <link linkend=\"RefObject\">geometry subtypes</link> (e.g. "
"POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, "
"GEOMETRYCOLLECTION, etc). The modifier supports coordinate dimensionality "
"restrictions by adding suffixes: Z, M and ZM. For example, a modifier of "
"'LINESTRINGM' allows only linestrings with three dimensions, and treats the "
"third dimension as a measure. Similarly, 'POINTZM' requires four dimensional "
"(XYZM) data."
msgstr ""
"유형 변경자가 허용하는 값은 다음과 같습니다. POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. 또 이 변경자는 Z, M 및 ZM이라는 접"
"미사를 통해 차원수 제약도 지원합니다. 따라서, 예를 들자면 'LINESTRINGM'의 변"
"경자는 3차원 이하의 라인 스트링만을 허용할 것이며, 세 번째 차원을 기준으로 취"
"급할 것입니다. 마찬가지로 'POINTZM'은 네 가지 차원의 데이터를 입력해야 할 것"
"입니다."

#. Tag: para
#: using_postgis_dataman.xml:1460
#, no-c-format
msgid ""
"the <emphasis role=\"bold\">SRID modifier</emphasis> restricts the <link "
"linkend=\"spatial_ref_sys\">spatial reference system</link> SRID to a "
"particular number. If omitted, the SRID defaults to 0."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1469
#, no-c-format
msgid "Examples of creating tables with geometry columns:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1472
#, no-c-format
msgid "Create a table holding any kind of geometry with the default SRID:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1476
#, no-c-format
msgid "Create a table with 2D POINT geometry with the default SRID:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1480
#, no-c-format
msgid "Create a table with 3D (XYZ) POINTs and an explicit SRID of 3005:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1484
#, no-c-format
msgid ""
"Create a table with 4D (XYZM) LINESTRING geometry with the default SRID:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1488
#, no-c-format
msgid ""
"Create a table with 2D POLYGON geometry with the SRID 4267 (NAD 1927 long "
"lat):"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1493
#, no-c-format
msgid ""
"It is possible to have more than one geometry column in a table. This can be "
"specified when the table is created, or a column can be added using the "
"<ulink url=\"https://www.postgresql.org/docs/current/sql-altertable."
"html\">ALTER TABLE</ulink> SQL statement. This example adds a column that "
"can hold 3D LineStrings:"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1503
#, fuzzy, no-c-format
msgid "GEOMETRY_COLUMNS View"
msgstr "The GEOMETRY_COLUMNS VIEW"

#. Tag: para
#: using_postgis_dataman.xml:1505
#, fuzzy, no-c-format
msgid ""
"The OGC <emphasis>Simple Features Specification for SQL</emphasis> defines "
"the <varname>GEOMETRY_COLUMNS</varname> metadata table to describe geometry "
"table structure. In PostGIS <varname>geometry_columns</varname> is a view "
"reading from database system catalog tables. This ensures that the spatial "
"metadata information is always consistent with the currently defined tables "
"and views. The view structure is:"
msgstr ""
"OpenGIS의 \"SQL 용 단순 피처 사양서(Simple Features Specification for "
"SQL)\"는 표준 GIS 객체 유형, 그 유형들을 다루기 위해 필요한 함수, 그리고 메타"
"데이터 테이블의 집합을 정의합니다. 메타데이터의 일관성을 유지하기 위해 공간 "
"열 생성 및 삭제와 같은 작업은 OpenGIS가 정의한 특별한 과정을 거쳐 이루어집니"
"다."

#. Tag: term
#: using_postgis_dataman.xml:1518
#, no-c-format
msgid "f_table_catalog, f_table_schema, f_table_name"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1521
#, fuzzy, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. There is no PostgreSQL analogue of \"catalog\" so that column is "
"left blank. For \"schema\" the PostgreSQL schema name is used "
"(<varname>public</varname> is the default)."
msgstr ""
"도형 열을 담고 있는 피처 테이블의 조건을 완전히 만족하는 명칭입니다. \"카탈로"
"그\"와 \"스키마\"가 오라클 용어라는 점을 주목하십시오. \"카탈로그\"를 대체하"
"는 PostgreSQL 용어가 없기 때문에 해당 열은 공백으로 남게 됩니다. \"스키마"
"\"의 경우 PostgreSQL 스키마 명칭이 사용됩니다(기본값은 <varname>public</"
"varname> 입니다)."

#. Tag: term
#: using_postgis_dataman.xml:1529
#, fuzzy, no-c-format
msgid "f_geometry_column"
msgstr "\\d geometry_columns"

#. Tag: para
#: using_postgis_dataman.xml:1532
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr "피처 테이블이 담고 있는 도형 열의 명칭입니다."

#. Tag: term
#: using_postgis_dataman.xml:1537
#, no-c-format
msgid "coord_dimension"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1540
#, fuzzy, no-c-format
msgid "The coordinate dimension (2, 3 or 4) of the column."
msgstr "열의 공간 차원(2, 3, 또는 4차원)입니다."

#. Tag: para
#: using_postgis_dataman.xml:1548
#, fuzzy, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>spatial_ref_sys</"
"varname> table (see <xref linkend=\"spatial_ref_sys_table\"/>)."
msgstr ""
"해당 테이블이 담고 있는 도형의 좌표가 사용하는 공간 좌표 시스템의 ID로, "
"<varname>SPATIAL_REF_SYS</varname> 를 참조하는 외래 키(foreign key)입니다."

#. Tag: term
#: using_postgis_dataman.xml:1556
#, no-c-format
msgid "type"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1559
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"공간 객체의 유형입니다. 공간 열을 단일 유형으로 제약하려면 다음 유형 가운데 "
"하나를 이용하십시오. POINT, LINESTRING, POLYGON, MULTIPOINT, "
"MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION 또는 이에 상응하는 XYM 버전"
"의 POINTM, LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, "
"MULTIPOLYGONM, GEOMETRYCOLLECTIONM. 혼합 유형 집합을 이용하려면 유형으로 "
"\"GEOMETRY\"를 이용할 수 있습니다."

#. Tag: title
#: using_postgis_dataman.xml:1572
#, fuzzy, no-c-format
msgid "Manually Registering Geometry Columns"
msgstr "geometry_columns에 도형 열을 직접 등록하기"

#. Tag: para
#: using_postgis_dataman.xml:1574
#, fuzzy, no-c-format
msgid ""
"Two of the cases where you may need this are the case of SQL Views and bulk "
"inserts. For bulk insert case, you can correct the registration in the "
"geometry_columns table by constraining the column or doing an alter table. "
"For views, you could expose using a CAST operation. Note, if your column is "
"typmod based, the creation process would register it correctly, so no need "
"to do anything. Also views that have no spatial function applied to the "
"geometry will register the same as the underlying table geometry column."
msgstr ""
"AddGeometryColumn() 함수를 쓸 수 없을 때 이런 일이 발생할 수 있는 두 가지 경"
"우가 있는데, SQL 뷰 그리고 대규모 삽입(bulk insert)의 경우입니다. 이런 경우, "
"해당 열에 제약 조건을 걸어서 geometry_columns 테이블 등록을 바로잡을 수 있습"
"니다. PostGIS 2.0 이상 버전에서는, 사용자 열이 typmod 기반이라면 생성 과정 중"
"에 정확하게 등록할 것이기 때문에 아무것도 할 필요가 없다는 점을 기억하십시오."

#. Tag: para
#: using_postgis_dataman.xml:1582
#, fuzzy, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""
"구식 제약조건 기반 방법을 여전히 지원하긴 하지만, 뷰에서 직접적으로 사용되는 "
"제약조건 기반 도형 열은 typmod 기반 열과는 달리 geometry_columns 테이블에 정"
"확하게 등록되지 않을 겁니다. 다음은 typmod를 이용하는 열과 제약조건을 이용하"
"는 또다른 열을 정의하는 예시입니다."

#. Tag: para
#: using_postgis_dataman.xml:1586
#, no-c-format
msgid "If we run in psql"
msgstr "PSQL에서 실행할 경우"

#. Tag: para
#: using_postgis_dataman.xml:1588
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr ""
"두 열이 서로 다르게 정의되었다는 사실을 알 수 있습니다. 하나는 typmod, 다른 "
"하나는 제약조건으로 정의되었습니다."

#. Tag: para
#: using_postgis_dataman.xml:1590
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "둘 다 geometry_columns 테이블에 정확하게 등록됩니다."

#. Tag: para
#: using_postgis_dataman.xml:1593
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "하지만 -- 다음과 같은 뷰를 생성하려 한다면"

#. Tag: para
#: using_postgis_dataman.xml:1595
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"typmod 기반 도형 열은 정확하게 등록되지만, 제약조건 기반 도형 열은 정확하게 "
"등록되지 않습니다."

#. Tag: para
#: using_postgis_dataman.xml:1599
#, fuzzy, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now to force the "
"constraint-based view column to register correctly, you need to do this:"
msgstr ""
"PostGIS 향후 버전에서는 변경될 수도 있지만, 현재 버전에서 제약조건 기반 뷰 열"
"을 정확하게 등록하려면 다음과 같이 해야 합니다:"

#. Tag: title
#: using_postgis_dataman.xml:1609
#, fuzzy, no-c-format
msgid "Loading Spatial Data"
msgstr "GIS (벡터) 데이터 로드"

#. Tag: para
#: using_postgis_dataman.xml:1611
#, fuzzy, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload spatial data "
"to the database. There are two built-in ways to get spatial data into a "
"PostGIS/PostgreSQL database: using formatted SQL statements or using the "
"Shapefile loader."
msgstr ""
"공간 테이블 생성을 끝냈다면, 사용자가 데이터베이스에 GIS 데이터를 업로드할 준"
"비가 된 것입니다. 현재, 형식화된 SQL 구문을 사용하거나 shapefile 로더/덤퍼를 "
"사용하는 두 가지 방법으로 PostGIS/PostgreSQL 데이터베이스에 데이터를 입력할 "
"수 있습니다."

#. Tag: title
#: using_postgis_dataman.xml:1617
#, fuzzy, no-c-format
msgid "Using SQL to Load Data"
msgstr "SQL을 이용해 데이터 가져오기"

#. Tag: para
#: using_postgis_dataman.xml:1619
#, fuzzy, no-c-format
msgid ""
"If spatial data can be converted to a text representation (as either WKT or "
"WKB), then using SQL might be the easiest way to get data into PostGIS. Data "
"can be bulk-loaded into PostGIS/PostgreSQL by loading a text file of SQL "
"<code>INSERT</code> statements using the <code>psql</code> SQL utility."
msgstr ""
"사용자 데이터를 텍스트 표현식으로 변환할 수 있다면, PostGIS에 사용자 데이터"
"를 입력하는 가장 쉬운 방법은 형식화된(formatted) SQL을 이용하는 것입니다. "
"Oracle이나 다른 SQL 데이터베이스와 마찬가지로, SQL 터미널 모니터에 SQL "
"\"INSERT\" 선언문으로 가득 찬 대용량 텍스트 파일을 송신하는(piping) 방법으로 "
"데이터를 일괄 로드시킬 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1624
#, fuzzy, no-c-format
msgid ""
"A SQL load file (<filename>roads.sql</filename> for example) might look like "
"this:"
msgstr ""
"데이터 업로드 파일(예를 들어 <filename>roads.sql</filename>)은 다음처럼 보일 "
"것입니다:"

#. Tag: para
#: using_postgis_dataman.xml:1629
#, fuzzy, no-c-format
msgid "The SQL file can be loaded into PostgreSQL using <code>psql</code>:"
msgstr ""
"\"psql\" SQL 터미널 모니터를 이용해서 PostgreSQL로 데이터 파일을 매우 쉽게 송"
"신할 수 있습니다."

#. Tag: title
#: using_postgis_dataman.xml:1635
#, fuzzy, no-c-format
msgid "Using the Shapefile Loader"
msgstr "shp2pgsql: ESRI shapefile 로더 이용하기"

#. Tag: para
#: using_postgis_dataman.xml:1637
#, fuzzy, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts Shapefiles into SQL "
"suitable for insertion into a PostGIS/PostgreSQL database either in geometry "
"or geography format. The loader has several operating modes selected by "
"command line flags."
msgstr ""
"<filename>shp2pgsql</filename> 데이터 로더는 ESRI shapefile을, 도형 형식이든 "
"지리형 형식이든, PostGIS/PostgreSQL 데이터베이스로 삽입하기에 적합한 SQL로 변"
"환합니다. 이 로더에는 명령행(command line) 플래그로 구별되는 몇 가지 실행 모"
"드가 존재합니다."

#. Tag: para
#: using_postgis_dataman.xml:1642
#, fuzzy, no-c-format
msgid ""
"There is also a <filename>shp2pgsql-gui</filename> graphical interface with "
"most of the options as the command-line loader. This may be easier to use "
"for one-off non-scripted loading or if you are new to PostGIS. It can also "
"be configured as a plugin to PgAdminIII."
msgstr ""
"shp2pgsql 명령행 로더 외에, 사용자가 PostGIS를 처음 접하는 경우 스크립트를 사"
"용하지 않고 단 한 번 로드하는 데 더 쉽게 사용할 수 있을 뿐만 아니라 명령행 로"
"더가 가진 대부분의 옵션도 가지고 있는 <filename>shp2pgsql-gui</filename> 그래"
"픽 인터페이스도 있습니다. <filename>shp2pgsql-gui</filename>를 pgAdmin III의 "
"플러그인으로 설정할 수도 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1650
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "c|a|d|p -- 이들은 상호배타적인 옵션들입니다:"

#. Tag: term
#: using_postgis_dataman.xml:1655
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1657
#, fuzzy, no-c-format
msgid ""
"Creates a new table and populates it from the Shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"새 테이블을 생성한 다음 shapefile의 데이터로 해당 테이블을 채웁니다. "
"<emphasis>이것이 기본 모드입니다.</emphasis>"

#. Tag: term
#: using_postgis_dataman.xml:1665
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1667
#, fuzzy, no-c-format
msgid ""
"Appends data from the Shapefile into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"기존 데이터베이스 테이블에 shapefile의 데이터를 추가합니다. 이 옵션을 이용해"
"서 복수의 파일을 로드하려면, 파일들이 동일한 속성 및 동일한 데이터 유형을 담"
"고 있어야 한다는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1676
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1678
#, fuzzy, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shapefile."
msgstr ""
"기존 데이터베이스 테이블을 삭제(drop)한 다음 shapefile의 데이터를 가진 새 테"
"이블을 생성합니다."

#. Tag: term
#: using_postgis_dataman.xml:1685
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1687
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"테이블을 생성하는 SQL 코드만 생성하고, 어떤 실제 데이터도 추가하지 않습니다. "
"테이블 생성과 데이터 로드 단계를 완전히 분리해야 할 경우 사용할 수 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1700
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1702
#, no-c-format
msgid "Display help screen."
msgstr "도움말 화면을 표출합니다."

#. Tag: term
#: using_postgis_dataman.xml:1709
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1711
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"산출물 데이터의 형식으로 PostgreSQL \"덤프(dump)\" 형식을 사용합니다. 이 옵션"
"은 -a, -c 및 -d와 함께 사용할 수 있습니다. 이 덤프 형식은 기본 \"삽입\" SQL "
"형식보다 훨씬 빨리 로드할 수 있습니다. 대용량 데이터셋의 경우 이 옵션을 사용"
"하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1720
#, fuzzy, no-c-format
msgid "-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1722
#, fuzzy, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID."
msgstr ""
"도형 테이블을 생성하고 지정된 SRID로 채웁니다. 입력 shapefile이 주어진 "
"FROM_SRID를 쓰도록 설정하는 옵션도 있습니다. 이런 경우 도형이 목표 SRID로 재"
"투영될 것입니다. FROM_SRID는 -D 옵션과 함께 사용될 수 없습니다."

#. Tag: term
#: using_postgis_dataman.xml:1732
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1734
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"식별자의 대소문자(열, 스키마 및 속성)를 유지합니다. shapefile 안의 속성은 모"
"두 대문자라는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1742
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1744
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"DBF 헤더 서명이 64비트 bigint 형식을 보장하더라도, 모든 정수를 표준 32비트 정"
"수로 강제 변환하고 64비트 bigint 형식을 생성하지 않습니다."

#. Tag: term
#: using_postgis_dataman.xml:1752
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1754
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "도형 열에 GiST 인덱스를 생성합니다."

#. Tag: term
#: using_postgis_dataman.xml:1761
#, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-m</term>"

#. Tag: para
#: using_postgis_dataman.xml:1763
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""
"\"-m <filename>파일명</filename>\" 형식으로 (긴) 열 명칭과 10문자 DBF 열 명칭"
"을 매핑하는 목록을 담은 파일을 지정합니다. 이 파일의 내용은 공백으로 구분된 "
"두 명칭으로 이루어진 하나 이상의 행으로, 행 맨 앞과 맨 뒤에는 공백이 없어야 "
"합니다. 다음은 그 예시입니다:"

#. Tag: term
#: using_postgis_dataman.xml:1774
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1776
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"다중(multi) 도형 대신 단순 도형을 생성합니다. 이 옵션은 모든 도형이 실제로 단"
"일형(예: 단일 외곽선을 가진 다중 폴리곤 또는 단일 꼭짓점을 가진 다중 포인트)"
"일 경우에만 작동합니다."

#. Tag: term
#: using_postgis_dataman.xml:1785
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1787
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"산출 도형이 지정된 차원수를 가지도록 강제합니다. 차원수를 지시하는 데 다음 스"
"트링을 사용하십시오: 2D, 3DZ, 3DM, 4D"

#. Tag: para
#: using_postgis_dataman.xml:1791
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"입력물이 지정된 차원수보다 낮은 차원일 경우, 출력물의 해당 차원은 0으로 채워"
"질 것입니다. 입력물이 지정된 차원수보다 높은 차원일 경우, 필요 없는 차원은 제"
"거될 것입니다."

#. Tag: term
#: using_postgis_dataman.xml:1800
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1802
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"WKB 대신 WKT 형식으로 출력합니다. 정확도가 부족하기 때문에 좌표가 이동될 가능"
"성이 있다는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1810
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1812
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the "
"\"dump\" format always uses a transaction."
msgstr ""
"각 선언문을 상호처리를 이용하지 않고 자체적으로 실행합니다. 오류를 생성하는 "
"몇몇 망가진 도형이 있을 경우 이 옵션을 사용하면 괜찮은 데이터 대다수를 로드"
"할 수 있습니다. \"덤프\" 형식은 항상 상호처리를 이용하기 때문에 -D 플래그와 "
"함께 사용할 수 없다는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1822
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1824
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"입력 데이터(DBF 파일)의 인코딩을 지정합니다. 이 옵션을 사용하면, DBF의 모든 "
"속성을 지정된 인코딩에서 UTF8로 변환합니다. 그 결과로 생성되는 SQL 출력물은 "
"<code>SET CLIENT_ENCODING to UTF8</code> 명령어를 담게 되어, 백엔드에서 UTF8"
"을 데이터베이스 내부에서 이용하도록 설정된 어떤 인코딩으로든 재변환할 수 있습"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:1834
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1836
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr ""
"NULL 도형 처리 방침 -- insert*(상관없이 삽입), skip(건너뛰기), abort(중단)"

#. Tag: term
#: using_postgis_dataman.xml:1842
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1844
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"DBF 파일만 임포트합니다. 사용자 데이터에 대응하는 shapefile이 없다면, 자동적"
"으로 이 모드로 전환하여  DBF만 로드할 것입니다. 따라서 전체 shapefile 집합을 "
"가지고 있지만 도형을 빼고 속성 데이터만 필요한 경우에만 이 플래그를 설정해야 "
"합니다."

#. Tag: term
#: using_postgis_dataman.xml:1852
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1854
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"(경도/위도가 필요한) 도형 대신 WGS84 경위도(SRID=4326)를 쓰는 지리형을 이용합"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:1860
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1862
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"새 테이블을 위한 테이블스페이스를 지정합니다. -X 파라미터가 함께 쓰인 경우가 "
"아니라면 여전히 인덱스가 기본 테이블스페이스를 이용할 것입니다. PostgreSQL 문"
"서는 사용자 지정 테이블스페이스가 필요한 경우를 잘 설명하고 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1870
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1872
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"새 테이블의 인덱스를 위한 테이블스페이스를 지정합니다. 이 옵션은 기본 키"
"(primary key) 인덱스에 적용되며, -I 플래그를 함께 사용하는 경우 GiST 공간 인"
"덱스에도 적용됩니다."

#. Tag: term
#: using_postgis_dataman.xml:1879
#, fuzzy, no-c-format
msgid "<term>-Z</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1881
#, no-c-format
msgid ""
"When used, this flag will prevent the generation of <code>ANALYZE</code> "
"statements. Without the -Z flag (default behavior), the <code>ANALYZE</code> "
"statements will be generated."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1890
#, fuzzy, no-c-format
msgid ""
"An example session using the loader to create an input file and loading it "
"might look like this:"
msgstr ""
"다음은 로더를 이용해서 입력 파일을 생성하고 업로드하는 세션의 예시입니다:"

#. Tag: para
#: using_postgis_dataman.xml:1897
#, fuzzy, no-c-format
msgid "A conversion and load can be done in one step using UNIX pipes:"
msgstr ""
"UNIX 파이프(pipe)를 이용하면 모든 변환 및 업로드 작업을 한 번에 끝낼 수 있습"
"니다:"

#. Tag: title
#: using_postgis_dataman.xml:1906
#, fuzzy, no-c-format
msgid "Extracting Spatial Data"
msgstr "공간 테이블 생성"

#. Tag: para
#: using_postgis_dataman.xml:1908
#, fuzzy, no-c-format
msgid ""
"Spatial data can be extracted from the database using either SQL or the "
"Shapefile dumper. The section on SQL presents some of the functions "
"available to do comparisons and queries on spatial tables."
msgstr ""
"SQL이나 shapefile 로더/덤퍼를 이용해서 데이터베이스로부터 데이터를 추출할 수 "
"있습니다. SQL 단원에서 공간 테이블에 대한 비교 및 쿼리를 할 수 있는 몇몇 연산"
"자에 대해 논의할 것입니다."

#. Tag: title
#: using_postgis_dataman.xml:1914
#, fuzzy, no-c-format
msgid "Using SQL to Extract Data"
msgstr "SQL을 이용해 데이터 가져오기"

#. Tag: para
#: using_postgis_dataman.xml:1916
#, fuzzy, no-c-format
msgid ""
"The most straightforward way of extracting spatial data out of the database "
"is to use a SQL <code>SELECT</code> query to define the data set to be "
"extracted and dump the resulting columns into a parsable text file:"
msgstr ""
"데이터베이스로부터 데이터를 추출하는 가장 간단한 방법은 SQL 선별(select) 쿼리"
"로 반환될 레코드 및 열의 개수를 줄인 다음 해당 결과 열을 파싱 가능한 텍스트 "
"파일로 덤프받는 것입니다:"

#. Tag: para
#: using_postgis_dataman.xml:1923
#, fuzzy, no-c-format
msgid ""
"There will be times when some kind of restriction is necessary to cut down "
"the number of records returned. In the case of attribute-based restrictions, "
"use the same SQL syntax as used with a non-spatial table. In the case of "
"spatial restrictions, the following functions are useful:"
msgstr ""
"하지만, 반환되는 필드의 개수를 줄이기 위해 어떤 종류의 제약이 필요할 때가 있"
"을 것입니다. 속성 기반 제약의 경우, 일반적인 비공간 테이블의 경우와 동일한 "
"SQL 문법을 쓰면 됩니다. 공간 제약의 경우, 다음 유용한 연산자들을 쓸 수 있습니"
"다."

#. Tag: term
#: using_postgis_dataman.xml:1931
#, no-c-format
msgid "ST_Intersects"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1934
#, no-c-format
msgid "This function tells whether two geometries share any space."
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1939
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1942
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"이 연산자는 두 도형이 기하학적으로 동일한지를 테스트합니다.예를 들어, "
"'POLYGON((0 0,1 1,1 0,0 0))'과 'POLYGON((0 0,1 1,1 0,0 0))'이 동일한지를 말입"
"니다(동일합니다)."

#. Tag: para
#: using_postgis_dataman.xml:1950
#, fuzzy, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries function. The 312 is a fictitious "
"spatial reference system that matches our data. So, for example:"
msgstr ""
"다음으로, 이 연산자들을 쿼리에 쓸 수 있습니다. SQL 명령행에 도형과 경계 상자"
"를 지정할 때, \"ST_GeomFromText()\" 함수를 이용해서 스트링 표현식을 도형으로 "
"정확하게 변환시켜야 합니다. 해당 데이터와 일치하는 가공의 공간 참조 시스템은 "
"312입니다. 다음은 그 예시입니다:"

#. Tag: para
#: using_postgis_dataman.xml:1958
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"이 쿼리는 해당 값과 동일한 도형을 담고 있는 \"ROADS_GEOM\" 테이블로부터 단일 "
"레코드를 반환할 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:1961
#, no-c-format
msgid ""
"To check whether some of the roads passes in the area defined by a polygon:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1967
#, fuzzy, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map "
"frame\" worth of data for display."
msgstr ""
"가장 흔한 공간 쿼리는 아마도 데이터 브라우저 또는 웹 매퍼 같은 클라이언트 소"
"프트웨어가 화면 표출을 위해 \"맵 프레임(map frame)\" 용량에 해당하는 데이터"
"를 가져오기 위해 사용하는 \"프레임 기반(frame-based)\" 쿼리일 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:1970
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"\"&amp;&amp;\" 연산자 사용시, 비교 피처로 BOX3D 또는 도형을 지정할 수 있습니"
"다. 하지만 도형을 지정했을 경우, 비교 작업에 해당 경계 상자가 사용될 것입니"
"다."

#. Tag: para
#: using_postgis_dataman.xml:1974
#, no-c-format
msgid "Using a \"BOX3D\" object for the frame, such a query looks like this:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1978
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr ""
"화면에 해당하는 데이터의 투영체를 지정하는 데 SRID 312를 썼다는 사실에 주의하"
"십시오."

#. Tag: title
#: using_postgis_dataman.xml:1984
#, fuzzy, no-c-format
msgid "Using the Shapefile Dumper"
msgstr "덤퍼 이용하기"

#. Tag: para
#: using_postgis_dataman.xml:1986
#, fuzzy, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects to the database and "
"converts a table (possibly defined by a query) into a shape file. The basic "
"syntax is:"
msgstr ""
"<filename>pgsql2shp</filename> 테이블 덤퍼는 데이터베이스에 직접 연결되어 (아"
"마도 쿼리가 정의했을) 테이블을 shapefile로 변환합니다. 기본 문법은 다음과 같"
"습니다:"

#. Tag: para
#: using_postgis_dataman.xml:1994
#, no-c-format
msgid "The commandline options are:"
msgstr "다음과 같은 명령행 옵션이 있습니다:"

#. Tag: term
#: using_postgis_dataman.xml:1998
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:2001
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "특정 파일명으로 출력물을 작성합니다."

#. Tag: term
#: using_postgis_dataman.xml:2006
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:2009
#, no-c-format
msgid "The database host to connect to."
msgstr "연결할 데이터베이스 호스트를 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:2014
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:2017
#, no-c-format
msgid "The port to connect to on the database host."
msgstr "데이터베이스 호스트 연결시 사용할 포트를 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:2022
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:2025
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "데이터베이스 연결에 사용할 비밀번호를 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:2030
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:2033
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "데이터베이스 연결에 사용할 사용자명을 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:2038
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:2041
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"복수의 도형 열을 가진 테이블일 경우, shapefile 작성에 이용될 도형 열을 설정합"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:2047
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:2050
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"바이너리 커서를 사용하도록 설정합니다. 이 옵션을 쓰면 실행 속도가 빨라지지"
"만, 테이블 안에 있는 비(非) 도형 속성 가운데 하나라도 텍스트로 작성할 캐스트"
"(cast)가 부족할 경우 실행되지 않을 것입니다."

#. Tag: term
#: using_postgis_dataman.xml:2057
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:2060
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"로(raw) 모드입니다. <varname>gid</varname> 필드를 삭제하거나, 열 명칭을 제외"
"하지 않습니다."

#. Tag: term
#: using_postgis_dataman.xml:2066
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:2068
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"식별자를 10문자 명칭으로 다시 매핑(remap)합니다. 해당 파일의 내용은 공백으로 "
"구분된 두 심볼로 이루어진 복수의 행으로, 행 맨 앞과 맨 뒤에는 공백이 없어야 "
"합니다. VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER 등과 같은 예가 "
"있습니다."

#. Tag: title
#: using_postgis_dataman.xml:2081
#, fuzzy, no-c-format
msgid "Spatial Indexes"
msgstr "인덱스 빌드 작업"

#. Tag: para
#: using_postgis_dataman.xml:2083
#, fuzzy, no-c-format
msgid ""
"Spatial indexes make using a spatial database for large data sets possible. "
"Without indexing, a search for features requires a sequential scan of every "
"record in the database. Indexing speeds up searching by organizing the data "
"into a structure which can be quickly traversed to find matching records."
msgstr ""
"인덱스 덕분에 공간 데이터베이스가 대용량 데이터셋을 사용할 수 있습니다. 인덱"
"스 작업을 하지 않으면, 어떤 피처를 검색하든 데이터베이스 안의 모든 레코드를 "
"\"순차 스캔\"해야 할 것입니다. 인덱스 작업은 데이터를 특정 레코드를 찾기 위"
"해 빠르게 훑어갈 수 있는 검색 트리로 조직해서 검색 속도를 향상시킵니다. "
"PostgreSQL는 기본적으로 B-Tree, R-Tree, GiST 세 종류의 인덱스를 지원합니다."

#. Tag: para
#: using_postgis_dataman.xml:2089
#, no-c-format
msgid ""
"The B-tree index method commonly used for attribute data is not very useful "
"for spatial data, since it only supports storing and querying data in a "
"single dimension. Data such as geometry (which has 2 or more dimensions) "
"requires an index method that supports range query across all the data "
"dimensions. One of the key advantages of PostgreSQL for spatial data "
"handling is that it offers several kinds of index methods which work well "
"for multi-dimensional data: GiST, BRIN and SP-GiST indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2099
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"bold\">GiST (Generalized Search Tree)</emphasis> indexes "
"break up data into \"things to one side\", \"things which overlap\", "
"\"things which are inside\" and can be used on a wide range of data-types, "
"including GIS data. PostGIS uses an R-Tree index implemented on top of GiST "
"to index spatial data. GiST is the most commonly-used and versatile spatial "
"index method, and offers very good query performance."
msgstr ""
"GiST(Generalized Search Tree) 인덱스는 데이터를 \"한 쪽에 있는 것\", \"겹치"
"는 것\", \"내부에 있는 것\"으로 분해하며 GIS 데이터를 포함한 광범위한 데이터 "
"유형에 쓰일 수 있습니다. PostGIS는 GiST를 써서 GIS 데이터에 인덱스 작업을 한 "
"다음, 해당 데이터에 다시 작업된 R-Tree 인덱스를 이용합니다."

#. Tag: para
#: using_postgis_dataman.xml:2109
#, no-c-format
msgid ""
"<emphasis role=\"bold\">BRIN (Block Range Index)</emphasis> indexes operate "
"by summarizing the spatial extent of ranges of table records. Search is done "
"via a scan of the ranges. BRIN is only appropriate for use for some kinds of "
"data (spatially sorted, with infrequent or no update). But it provides much "
"faster index create time, and much smaller index size."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2119
#, no-c-format
msgid ""
"<emphasis role=\"bold\">SP-GiST (Space-Partitioned Generalized Search Tree)</"
"emphasis> is a generic index method that supports partitioned search trees "
"such as quad-trees, k-d trees, and radix trees (tries)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2126
#, no-c-format
msgid ""
"Spatial indexes store only the bounding box of geometries. Spatial queries "
"use the index as a <emphasis role=\"bold\">primary filter</emphasis> to "
"quickly determine a set of geometries potentially matching the query "
"condition. Most spatial queries require a <emphasis role=\"bold\">secondary "
"filter</emphasis> that uses a spatial predicate function to test a more "
"specific spatial condition. For more information on queying with spatial "
"predicates see <xref linkend=\"using-query-indexes\"/>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2134
#, no-c-format
msgid ""
"See also the <ulink url=\"https://postgis.net/workshops/postgis-intro/"
"indexing.html\">PostGIS Workshop section on spatial indexes</ulink>, and the "
"<ulink url=\"https://www.postgresql.org/docs/current/indexes."
"html\">PostgreSQL manual</ulink>."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2140
#, no-c-format
msgid "GiST Indexes"
msgstr "GiST 인덱스"

#. Tag: para
#: using_postgis_dataman.xml:2142
#, fuzzy, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing for multi-dimensional data. PostGIS uses an R-Tree index "
"implemented on top of GiST to index spatial data. GiST is the most commonly-"
"used and versatile spatial index method, and offers very good query "
"performance. Other implementations of GiST are used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing. For more information see "
"the <ulink url=\"https://www.postgresql.org/docs/current/gist."
"html\">PostgreSQL manual</ulink>."
msgstr ""
"GiST는 \"일반화된 검색 트리\"의 줄임말로, 인덱스 작업의 포괄적인 형태입니다. "
"GIS 인덱스 작업 외에도, 일반 B-Tree 인덱스 작업으로는 쓸 수 없는 온갖 종류의 "
"비정규 데이터 구조(정수 배열, 분광 데이터 등등)에 대한 검색 속도를 향상시키"
"는 데 GiST를 이용합니다."

#. Tag: para
#: using_postgis_dataman.xml:2152
#, fuzzy, no-c-format
msgid ""
"Once a spatial data table exceeds a few thousand rows, you will want to "
"build an index to speed up spatial searches of the data (unless all your "
"searches are based on attributes, in which case you'll want to build a "
"normal index on the attribute fields)."
msgstr ""
"GIS 데이터 테이블이 수천 행을 넘게 되면, 데이터 공간 검색의 속도를 향상시키"
"기 위해 인덱스를 빌드하고 싶게 될 것입니다(사용자의 모든 검색이 속성에 기반하"
"는 경우가 아니라면 말입니다. 그런 경우, 속성 필드에 대해 일반 인덱스를 빌드하"
"면 됩니다)."

#. Tag: para
#: using_postgis_dataman.xml:2157
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr ""
"\"도형\" 열에 대해 GiST 인덱스를 빌드하는 데 필요한 문법은 다음과 같습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2162
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index for the geometry type, you can create one using this syntax:"
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2165
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2168 using_postgis_dataman.xml:2340
#, no-c-format
msgid ""
"After building an index, it is sometimes helpful to force PostgreSQL to "
"collect table statistics, which are used to optimize query plans:"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2176
#, fuzzy, no-c-format
msgid "BRIN Indexes"
msgstr "GiST 인덱스"

#. Tag: para
#: using_postgis_dataman.xml:2178
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\". It is a general-purpose index method "
"introduced in PostgreSQL 9.5. BRIN is a <emphasis>lossy</emphasis> index "
"method, meaning that a secondary check is required to confirm that a record "
"matches a given search condition (which is the case for all provided spatial "
"indexes). It provides much faster index creation and much smaller index "
"size, with reasonable read performance. Its primary purpose is to support "
"indexing very large tables on columns which have a correlation with their "
"physical location within the table. In addition to spatial indexing, BRIN "
"can speed up searches on various kinds of attribute data structures "
"(integer, arrays etc). For more information see the <ulink url=\"https://www."
"postgresql.org/docs/current/brin.html\">PostgreSQL manual</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2194
#, fuzzy, no-c-format
msgid ""
"Once a spatial table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data. GiST indexes are very "
"performant as long as their size doesn't exceed the amount of RAM available "
"for the database, and as long as you can afford the index storage size, and "
"the cost of index update on write. Otherwise, for very large tables BRIN "
"index can be considered as an alternative."
msgstr ""
"GIS 데이터 테이블이 수천 행을 넘게 되면, 데이터 공간 검색의 속도를 향상시키"
"기 위해 인덱스를 빌드하고 싶게 될 것입니다(사용자의 모든 검색이 속성에 기반하"
"는 경우가 아니라면 말입니다. 그런 경우, 속성 필드에 대해 일반 인덱스를 빌드하"
"면 됩니다)."

#. Tag: para
#: using_postgis_dataman.xml:2201
#, no-c-format
msgid ""
"A BRIN index stores the bounding box enclosing all the geometries contained "
"in the rows in a contiguous set of table blocks, called a <emphasis>block "
"range</emphasis>. When executing a query using the index the block ranges "
"are scanned to find the ones that intersect the query extent. This is "
"efficient only if the data is physically ordered so that the bounding boxes "
"for block ranges have minimal overlap (and ideally are mutually exclusive). "
"The resulting index is very small in size, but is typically less performant "
"for read than a GiST index over the same data."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2211
#, no-c-format
msgid ""
"Building a BRIN index is much less CPU-intensive than building a GiST index. "
"It's common to find that a BRIN index is ten times faster to build than a "
"GiST index over the same data. And because a BRIN index stores only one "
"bounding box for each range of table blocks, it's common to use up to a "
"thousand times less disk space than a GiST index."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2217
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably provide better "
"performance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2221
#, no-c-format
msgid ""
"For BRIN to be effective, the table data should be stored in a physical "
"order which minimizes the amount of block extent overlap. It may be that the "
"data is already sorted appropriately (for instance, if it is loaded from "
"another dataset that is already sorted in spatial order). Otherwise, this "
"can be accomplished by sorting the data by a one-dimensional spatial key. "
"One way to do this is to create a new table sorted by the geometry values "
"(which in recent PostGIS versions uses an efficient Hilbert curve ordering):"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2232
#, no-c-format
msgid ""
"Alternatively, data can be sorted in-place by using a GeoHash as a "
"(temporary) index, and clustering on that index:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2239
#, fuzzy, no-c-format
msgid ""
"The syntax for building a BRIN index on a <code>geometry</code> column is:"
msgstr ""
"\"도형\" 열에 대해 GiST 인덱스를 빌드하는 데 필요한 문법은 다음과 같습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2243
#, fuzzy, no-c-format
msgid ""
"The above syntax builds a 2D index. To build a 3D-dimensional index, use "
"this syntax:"
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2247
#, no-c-format
msgid "You can also get a 4D-dimensional index using the 4D operator class:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2251
#, no-c-format
msgid ""
"The above commands use the default number of blocks in a range, which is "
"128. To specify the number of blocks to summarise in a range, use this syntax"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2256
#, no-c-format
msgid ""
"Keep in mind that a BRIN index only stores one index entry for a large "
"number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this performance penalty by choosing the operator class with "
"the least number of dimensions of the stored geometries"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2264
#, fuzzy, no-c-format
msgid ""
"The <code>geography</code> datatype is supported for BRIN indexing. The "
"syntax for building a BRIN index on a geography column is:"
msgstr ""
"\"도형\" 열에 대해 GiST 인덱스를 빌드하는 데 필요한 문법은 다음과 같습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2269
#, fuzzy, no-c-format
msgid ""
"The above syntax builds a 2D-index for geospatial objects on the spheroid."
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2271
#, no-c-format
msgid ""
"Currently, only \"inclusion support\" is provided, meaning that just the "
"<varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</varname> "
"operators can be used for the 2D cases (for both <code>geometry</code> and "
"<code>geography</code>), and just the <varname>&amp;&amp;&amp;</varname> "
"operator for 3D geometries. There is currently no support for kNN searches."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2278
#, no-c-format
msgid ""
"An important difference between BRIN and other index types is that the "
"database does not maintain the index dynamically. Changes to spatial data in "
"the table are simply appended to the end of the index. This will cause index "
"search performance to degrade over time. The index can be updated by "
"performing a <code>VACUUM</code>, or by using a special function "
"<code>brin_summarize_new_values(regclass)</code>. For this reason BRIN may "
"be most appropriate for use with data that is read-only, or only rarely "
"changing. For more information refer to the <ulink url=\"https://www."
"postgresql.org/docs/current/brin-intro.html#BRIN-OPERATION\">manual</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2288
#, no-c-format
msgid "To summarize using BRIN for spatial data:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2292
#, no-c-format
msgid "Index build time is very fast, and index size is very small."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2293
#, no-c-format
msgid "Index query time is slower than GiST, but can still be very acceptable."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2294
#, no-c-format
msgid "Requires table data to be sorted in a spatial ordering."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2295
#, no-c-format
msgid "Requires manual index maintenance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2296
#, no-c-format
msgid ""
"Most appropriate for very large tables, with low or no overlap (e.g. "
"points), which are static or change infrequently."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2299
#, no-c-format
msgid ""
"More effective for queries which return relatively large numbers of data "
"records."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2305
#, fuzzy, no-c-format
msgid "SP-GiST Indexes"
msgstr "GiST 인덱스"

#. Tag: para
#: using_postgis_dataman.xml:2307
#, no-c-format
msgid ""
"SP-GiST stands for \"Space-Partitioned Generalized Search Tree\" and is a "
"generic form of indexing for multi-dimensional data types that supports "
"partitioned search trees, such as quad-trees, k-d trees, and radix trees "
"(tries). The common feature of these data structures is that they repeatedly "
"divide the search space into partitions that need not be of equal size. In "
"addition to spatial indexing, SP-GiST is used to speed up searches on many "
"kinds of data, such as phone routing, ip routing, substring search, etc. For "
"more information see the <ulink url=\"https://www.postgresql.org/docs/"
"current/spgist.html\">PostgreSQL manual</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2319
#, no-c-format
msgid ""
"As it is the case for GiST indexes, SP-GiST indexes are lossy, in the sense "
"that they store the bounding box enclosing spatial objects. SP-GiST indexes "
"can be considered as an alternative to GiST indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2323
#, fuzzy, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, an SP-GiST index may be "
"used to speed up spatial searches of the data. The syntax for building an SP-"
"GiST index on a \"geometry\" column is as follows:"
msgstr ""
"GIS 데이터 테이블이 수천 행을 넘게 되면, 데이터 공간 검색의 속도를 향상시키"
"기 위해 인덱스를 빌드하고 싶게 될 것입니다(사용자의 모든 검색이 속성에 기반하"
"는 경우가 아니라면 말입니다. 그런 경우, 속성 필드에 대해 일반 인덱스를 빌드하"
"면 됩니다)."

#. Tag: para
#: using_postgis_dataman.xml:2329
#, fuzzy, no-c-format
msgid ""
"The above syntax will build a 2-dimensional index. A 3-dimensional index for "
"the geometry type can be created using the 3D operator class:"
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2334
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive operation. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2345
#, no-c-format
msgid ""
"An SP-GiST index can accelerate queries involving the following operators:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2347
#, no-c-format
msgid ""
"&lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, "
"|&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~=, for 2-dimensional indexes,"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2348
#, no-c-format
msgid "&amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@, for 3-dimensional indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2350
#, no-c-format
msgid "There is no support for kNN searches at the moment."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2353
#, fuzzy, no-c-format
msgid "Tuning Index Usage"
msgstr "인덱스 빌드 작업"

#. Tag: para
#: using_postgis_dataman.xml:2355
#, fuzzy, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once an index is built, "
"the PostgreSQL query planner automatically decides when to use it to improve "
"query performance. But there are some situations where the planner does not "
"choose to use existing indexes, so queries end up using slow sequential "
"scans instead of a spatial index."
msgstr ""
"일반적인 경우라면 인덱스는 눈에 보이지 않게 데이터 접속 속도를 향상시킵니다. "
"인덱스가 빌드된 후, 쿼리 설계자는 쿼리 설계의 속도를 향상기키는 데 언제 인덱"
"스 정보를 사용할 것인지 투명하게 결정합니다. 안타깝게도 PostgreSQL 쿼리 설계"
"자가 GiST 인덱스의 사용을 제대로 최적화시키지 못 하기 때문에, 종종 공간 인덱"
"스를 활용해야 할 검색이 대신 기본값인 전체 데이터의 순차 스캔을 이용할 때가 "
"있습니다."

#. Tag: para
#: using_postgis_dataman.xml:2361
#, fuzzy, no-c-format
msgid ""
"If you find your spatial indexes are not being used, there are a few things "
"you can do:"
msgstr ""
"사용자의 공간 인덱스가 (또는 사용자의 속성 인덱스가) 활용되지 않고 있다는 사"
"실을 알게 되었다면, 몇 가지 해결 방법이 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2366
#, no-c-format
msgid ""
"Examine the query plan and check your query actually computes the thing you "
"need. An erroneous JOIN, either forgotten or to the wrong table, can "
"unexpectedly retrieve table records multiple times. To get the query plan, "
"execute with <code>EXPLAIN</code> in front of the query."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2373
#, no-c-format
msgid ""
"Make sure statistics are gathered about the number and distributions of "
"values in a table, to provide the query planner with better information to "
"make decisions around index usage. <command>VACUUM ANALYZE</command> will "
"compute both."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2378
#, no-c-format
msgid ""
"You should regularly vacuum your databases anyways. Many PostgreSQL DBAs run "
"<command>VACUUM</command> as an off-peak cron job on a regular basis."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2383
#, fuzzy, no-c-format
msgid ""
"If vacuuming does not help, you can temporarily force the planner to use the "
"index information by using the command <command>SET ENABLE_SEQSCAN TO OFF;</"
"command>. This way you can check whether the planner is at all able to "
"generate an index-accelerated query plan for your query. You should only use "
"this command for debugging; generally speaking, the planner knows better "
"than you do about when to use indexes. Once you have run your query, do not "
"forget to run <command>SET ENABLE_SEQSCAN TO ON;</command> so that the "
"planner will operate normally for other queries."
msgstr ""
"두 번째, 빈공간 분석으로 해결이 안 될 경우 <command>SET ENABLE_SEQSCAN=OFF</"
"command> 명령어를 통해 강제로 쿼리 설계자가 인덱스 정보를 이용하도록 할 수 있"
"습니다. 이 명령어는 공간 인덱스 쿼리일 경우에 한해 드물게 이용해야 합니다. 일"
"반적으로, 쿼리 설계자는 언제 일반 B-Tree 인덱스를 활용해야 하는지 사용자보다 "
"더 잘 알고 있습니다. 사용자 쿼리 실행 후, 다른 쿼리가 평소처럼 쿼리 설계자를 "
"활용하도록 <varname>ENABLE_SEQSCAN</varname> 을 다시 켤지 고려해봐야 합니다."

#. Tag: para
#: using_postgis_dataman.xml:2395
#, fuzzy, no-c-format
msgid ""
"If <command>SET ENABLE_SEQSCAN TO OFF;</command> helps your query to run "
"faster, your Postgres is likely not tuned for your hardware. If you find the "
"planner wrong about the cost of sequential versus index scans try reducing "
"the value of <varname>RANDOM_PAGE_COST</varname> in <code>postgresql.conf</"
"code>, or use <command>SET RANDOM_PAGE_COST TO 1.1;</command>. The default "
"value for <varname>RANDOM_PAGE_COST</varname> is 4.0. Try setting it to 1.1 "
"(for SSD) or 2.0 (for fast magnetic disks). Decreasing the value makes the "
"planner more likely to use index scans."
msgstr ""
"쿼리 설계자가 순차 및 인덱스 스캔의 경중(cost)을 잘못 판단하고 있다면, "
"postgresql.conf 파일의 random_page_cost의 값을 줄여보거나 \"SET "
"random_page_cost=#\"로 써보십시오. 해당 파라미터의 기본값은 4이지만, 1또는 2"
"로 설정해보십시오. 값을 감소시킬수록 점점 더 쿼리 설계자가 인덱스 스캔을 활용"
"하게 될 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:2406
#, no-c-format
msgid ""
"If <command>SET ENABLE_SEQSCAN TO OFF;</command> does not help your query, "
"the query may be using a SQL construct that the Postgres planner is not yet "
"able to optimize. It may be possible to rewrite the query in a way that the "
"planner is able to handle. For example, a subquery with an inline SELECT may "
"not produce an efficient plan, but could possibly be rewritten using a "
"LATERAL JOIN."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2415
#, no-c-format
msgid ""
"For more information see the Postgres manual section on <ulink url=\"https://"
"www.postgresql.org/docs/current/runtime-config-query.html\">Query Planning</"
"ulink>."
msgstr ""
